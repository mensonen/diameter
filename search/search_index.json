{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Python Diameter Stack","text":"<p>This Python package provides tools to create and parse Diameter Messags and  AVPs, to communicate with diameter peers using the diameter base protocol and  to write diameter applications, as defined in <code>rfc6733</code>, <code>rfc8506</code> and  <code>rfc5777</code>. </p> <p>The package contains an extensive AVP dictionary and allows constructing AVPs and Diameter messages either manually, or by parsing network-received  bytes. For messages described in the Diameter Base and Diameter Credit Control RFCs, additional python types are provided, which permit reading and updating message AVPs as python instance properties.</p> <p>The <code>diameter</code> package provides tools for:</p> <ul> <li>Parsing and writing AVPs</li> <li>Parsing and writing diameter Mesages</li> <li>Creating diameter nodes and connecting to other peers</li> <li>Writing diameter applications</li> </ul> <p>In terms of diameter connectivity, the diameter stack supports both TCP and SCTP, with SCTP support provided by an optional depency on  pysctp.</p> <p>The diameter Application and Node implementations handle the majority of the  basic protocol-level operations automatically, such as managing peer tables,  sending CER/CEA, DWR/DEA and disconnecting with DPR/DPA. </p>"},{"location":"setup/","title":"Installation","text":""},{"location":"setup/#system-requirements","title":"System requirements","text":"<p>The <code>diameter</code> package can be installed from PyPI:</p> <pre><code>~# pip install python-diameter\n</code></pre> <p>The minimum required Python version is 3.11, a fairly recent Linux kernel is recommended. There is no Windows or Mac compatibility.</p>"},{"location":"setup/#sctp","title":"SCTP","text":"<p>The <code>diameter</code> stack can operate in both TCP and SCTP modes. For connectivity over the SCTP transport, an optional dependency for  pysctp must be installed separately:</p> <pre><code>~# pip install pysctp\n</code></pre> <p>Note that installing the <code>pysctp</code> package requires at least an SCTP-aware kernel and possibly additional OS packages installed prior installation. Refer to  pysctp installation documentation for further instructions.</p> <p>There is no need to make <code>diameter</code> package SCTP-aware. If pysctp is available, it will be used automatically for any peer configured to use the SCTP  transport protocol.</p>"},{"location":"api/","title":"API reference","text":""},{"location":"api/application/","title":"Application","text":"<p>API reference for <code>diameter.node.application</code>.</p> <p>Diameter application implementations.</p> <p>Instances of Applications, or their subclasses, provided by this module can be passed directly to an instance of a <code>Node</code>, for receiving and sending diameter application messages.</p> <p>In most cases, the most suitable option to use is <code>SimpleThreadingApplication</code>, which will cover the most scenarios without requiring any unnecessary setup.</p>"},{"location":"api/application/#diameter.node.application.Application","title":"Application","text":"<pre><code>Application(application_id: int = None, is_acct_application: bool = False, is_auth_application: bool = False)\n</code></pre> <p>A basic diameter application that can be registered with a Node.</p> <p>Can be used as a starting point for building applications with custom logic. In most cases, <code>SimpleThreadingApplication</code> and <code>ThreadingApplication</code> are more practical.</p> <p>Parameters:</p> Name Type Description Default <code>application_id</code> <code>int</code> <p>Authentication application ID</p> <code>None</code> <code>is_acct_application</code> <code>bool</code> <p>Flag the application as an accounting app</p> <code>False</code> <code>is_auth_application</code> <code>bool</code> <p>Flag the application as an authorisation app</p> <code>False</code>"},{"location":"api/application/#diameter.node.application.Application.generate_answer","title":"generate_answer","text":"<pre><code>generate_answer(message: _AnyMessageType, result_code: int = None, error_message: str = None) -&gt; _AnyAnswerType\n</code></pre> <p>Produce an answer message from a request message.</p> <p>Calls Message.to_answer and adds origin host, origin realm, session id and application IDs automatically.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>_AnyMessageType</code> <p>Any diameter message with a python implementation, accepting AVPs as instance attributes</p> required <code>result_code</code> <code>int</code> <p>An optional result code to add to the answer</p> <code>None</code> <code>error_message</code> <code>str</code> <p>An optional error message to add to the answer</p> <code>None</code>"},{"location":"api/application/#diameter.node.application.Application.handle_answer","title":"handle_answer","text":"<pre><code>handle_answer(message: Message)\n</code></pre> <p>Called every time an unexpected answer message is received.</p> <p>Normally, answers are returned directly as the return values of <code>send_request</code>; overriding this method is not strictly required. It is called every time an answer is received, with nobody expecting one. This could happen e.g. when the answer wait timeout has been exceeded. By default, this method does nothing and only discards every unexpected message.</p> <p>Warning</p> <p>This method is called in the main thread; its execution blocks the diameter Node from processing any incoming or outgoing messages. The implementing party is expected to utilise a message queue and do the work in a separate thread.</p>"},{"location":"api/application/#diameter.node.application.Application.handle_request","title":"handle_request","text":"<pre><code>handle_request(message: Message)\n</code></pre> <p>Called every time a request message is received.</p> <p>The parent diameter node does not check or expect this method to return anyhing; the application is expected to send its answer messages back towards the network by using the <code>send_message</code> method.</p> <p>Warning</p> <p>This method is called in the main thread; its execution blocks the diameter Node from processing any incoming or outgoing messages. The implementing party is expected to utilise a message queue and do the work in a separate thread. Alternatively, the ThreadingApplication can be used, which spawns a new thread for every request.</p>"},{"location":"api/application/#diameter.node.application.Application.send_answer","title":"send_answer","text":"<pre><code>send_answer(message: Message)\n</code></pre> <p>Send an answer message.</p> <p>Routes the message directly to the parent diameter node, where it will be forwarded through the network to the appropriate peer. The application ID, hop-by-hop identifier and end-to-end identifiers must already be set (copied from the original request).</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Message</code> <p>A diameter message to send</p> required <p>The method will return nothing; it returns immediately without waiting for any results from the network.</p>"},{"location":"api/application/#diameter.node.application.Application.send_request","title":"send_request","text":"<pre><code>send_request(message: Message, timeout: int = 30) -&gt; Message\n</code></pre> <p>Send a request message.</p> <p>Routes the message directly to the parent diameter node, where it will be forwarded through the network to the appropriate peer. The header application ID and end-to-end hop identifiers are set automatically, if not already present.</p> <p>The hop-by-hop identifier will be set by the node, if the message can be routed to a peer and if the identifier is not already present.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Message</code> <p>A diameter message to send</p> required <code>timeout</code> <code>int</code> <p>A timeout in seconds to wait for an answer</p> <code>30</code> <p>Returns:</p> Type Description <code>Message</code> <p>A diameter answer message, if one was received within the timeout seconds, otherwise <code>None</code>. If the sent message was not a request, returns <code>None</code> immediately without waiting.</p>"},{"location":"api/application/#diameter.node.application.Application.wait_for_ready","title":"wait_for_ready","text":"<pre><code>wait_for_ready(timeout: int = 30)\n</code></pre> <p>Wait for application connectivity to become ready.</p> <p>Waits until at least one of the peers specified for the application has completed its CER/CEA procedure and become ready to accept requests. If all the configured peers for the application become again disconnected, <code>wait_for_ready</code> will block again, until at least one of the peers has returned and completed their CER/CEA.</p> <p>Note</p> <p>This method can be called every time before <code>send_request</code> is to be used, for increased certainty that a request will go through, however it will not guarantee that a peer will not go offline between calling this method and sending the request.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int</code> <p>Amount of time to wait, in seconds</p> <code>30</code> <p>Raises:</p> Type Description <code>ApplicationError</code> <p>If no peer becomes available before timeout</p>"},{"location":"api/application/#diameter.node.application.ApplicationError","title":"ApplicationError","text":"<p>             Bases: <code>Exception</code></p> <p>Base error class for all Application-raised errors.</p>"},{"location":"api/application/#diameter.node.application.EmptyAnswer","title":"EmptyAnswer","text":"<p>             Bases: <code>ApplicationError</code></p> <p>An error received when a diameter peer fails to respond.</p>"},{"location":"api/application/#diameter.node.application.RequestTimeout","title":"RequestTimeout","text":"<p>             Bases: <code>ApplicationError</code></p> <p>An error received when no answer is received within a given timeout.</p>"},{"location":"api/application/#diameter.node.application.SimpleThreadingApplication","title":"SimpleThreadingApplication","text":"<pre><code>SimpleThreadingApplication(application_id: int = None, is_acct_application: bool = False, is_auth_application: bool = False, max_threads: int = 0, request_handler: Callable = None)\n</code></pre> <p>             Bases: <code>ThreadingApplication</code></p> <p>A diameter application that starts a thread for each request.</p> <p>An alternative to the base threading application, that does not require subclassing or overwriting. The implementing party should pass a callback function in the <code>request_handler</code> argument. The application will call the passed function for every received request in a separate thread, passing an instance of the app itself and the message to handle as arguments.</p> <p>If the application acts as a client only and never expects any requests, the callback function is optional.</p> <pre><code>from diameter.node.application import SimpleThreadingApplication\nfrom diameter.message import constants\n\ndef handle_request(app: Application, message: Message):\n    print(\"Got\", message)\n    answer = app.generate_answer(message)\n    return answer\n\napp = SimpleThreadingApplication(\n    constants.APP_DIAMETER_BASE_ACCOUNTING,\n    is_acct_application=True,\n    request_handler=handle_request)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>application_id</code> <code>int</code> <p>Authentication application ID</p> <code>None</code> <code>is_acct_application</code> <code>bool</code> <p>Flag the application as an accounting app</p> <code>False</code> <code>is_auth_application</code> <code>bool</code> <p>Flag the application as an authorisation app</p> <code>False</code> <code>max_threads</code> <code>int</code> <p>Maximum threads to start simultaneously for processing messages. When maximum thread count is reached, the application does not handle any further messages, until at least one of the already started threads has exited. If set to 0, the amount of threads to spawn is unlimited.</p> <code>0</code> <code>request_handler</code> <code>Callable</code> <p>Any callable that will be called whenever a request is received. It will receive an instance of the app and request message as its arguments and is expected to return an answer message</p> <code>None</code>"},{"location":"api/application/#diameter.node.application.ThreadingApplication","title":"ThreadingApplication","text":"<pre><code>ThreadingApplication(application_id: int = None, is_acct_application: bool = False, is_auth_application: bool = False, max_threads: int = 0)\n</code></pre> <p>             Bases: <code>Application</code></p> <p>A diameter application that starts a thread for each request.</p> <p>An alternative to the base application, where each message received by the diameter node is handled in a separate thread. The implementing party should override the <code>handle_request</code> method and do the message processing work within, returning a new answer.</p> <p>Parameters:</p> Name Type Description Default <code>application_id</code> <code>int</code> <p>Authentication application ID</p> <code>None</code> <code>is_acct_application</code> <code>bool</code> <p>Flag the application as an accounting app</p> <code>False</code> <code>is_auth_application</code> <code>bool</code> <p>Flag the application as an authorisation app</p> <code>False</code> <code>max_threads</code> <code>int</code> <p>Maximum threads to start simultaneously for processing messages. When maximum thread count is reached, the application does not handle any further messages, until at least one of the already started threads has exited. If set to 0, the amount of threads to spawn is unlimited.</p> <code>0</code>"},{"location":"api/application/#diameter.node.application.ThreadingApplication.handle_request","title":"handle_request","text":"<pre><code>handle_request(message: Message) -&gt; Message | None\n</code></pre> <p>Called by diameter node every time a request message is received.</p> <p>Unlike the base <code>Application</code> version of this same method, the <code>handle_request</code> is expected to return an answer, either <code>None</code> or a valid diameter Message. The return value of the method is sent automatically back towards the network. Any exceptions raised by the method are caught and result in a DIAMETER_UNABLE_TO_COMPLY result being returned to the network.</p>"},{"location":"api/message/","title":"Message","text":"<p>API reference for <code>diameter.message</code>.</p> <p>Diameter base message implementation.</p> <p>This module contains the base functions for encoding and decoding diameter message headers and messages.</p>"},{"location":"api/message/#diameter.message.Message","title":"Message","text":"<pre><code>Message(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>Base message class.</p> <p>All implemented diameter commands extend this class.</p> <p>The base message class is not intended to be used directly; its main purpose is to provide the Message.from_bytes class method, for parsing network-received bytes into Python diameter command message instances.</p>"},{"location":"api/message/#diameter.message.Message.code","title":"code  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>code: int = 0\n</code></pre> <p>Diameter command code value.</p>"},{"location":"api/message/#diameter.message.Message.header","title":"header  <code>instance-attribute</code>","text":"<pre><code>header: MessageHeader = header or MessageHeader()\n</code></pre> <p>A message header. Always exists, defaults to an empty header for  new messages.</p> <p>Note</p> <p>The <code>lenght</code> property of the message header is zero for newly  created messages and will not be set until the message is rendered using the as_bytes method.</p>"},{"location":"api/message/#diameter.message.Message.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = 'Unknown'\n</code></pre> <p>A human-readable diameter command code name, e.g. \"Accounting-Request\".</p>"},{"location":"api/message/#diameter.message.Message.append_avp","title":"append_avp","text":"<pre><code>append_avp(avp: Avp)\n</code></pre> <p>Add an AVP to the internal list of AVPs.</p>"},{"location":"api/message/#diameter.message.Message.as_bytes","title":"as_bytes","text":"<pre><code>as_bytes() -&gt; bytes\n</code></pre> <p>Retrieve entire message as bytes.</p> <p>Retrieving the message also builds each AVP it contains. Until this point, the list of AVPs has not been built yet and the message header length is still zero. The header length is updated every time <code>as_bytes()</code> is called.</p>"},{"location":"api/message/#diameter.message.Message.find_avps","title":"find_avps","text":"<pre><code>find_avps(*code_and_vendor: tuple[int, int], alt_list: list[Avp] = None) -&gt; list[Avp]\n</code></pre> <p>Find specific AVPs in the message internal AVP tree.</p> <p>If more than one <code>code_and_vendor</code> pair is given, the list is assumed to be a chain of AVPs to follow. The returned list of AVPs will be the AVPs found at the end of each chain.</p> <p>Examples:</p> <p>In an AVP structure such as:</p> <pre><code>Multiple-Services-Credit-Control &lt;Code: 0x1c8, Flags: 0x40 (-M-), Length: 168&gt;\n  Requested-Service-Unit &lt;Code: 0x1b5, Flags: 0x40 (-M-), Length: 0&gt;\n  Used-Service-Unit &lt;Code: 0x1be, Flags: 0x40 (-M-), Length: 84&gt;\n    CC-Time &lt;Code: 0x1a4, Flags: 0x40 (-M-), Length: 12, Val: 9&gt;\n    CC-Total-Octets &lt;Code: 0x1a5, Flags: 0x40 (-M-), Length: 16, Val: 0&gt;\n</code></pre> <p>The \"CC-Total-Octets\" AVP can be found with:</p> <pre><code>&gt;&gt;&gt; msg = Message()\n&gt;&gt;&gt; avp = msg.find_avps(\n&gt;&gt;&gt;     (AVP_MULTIPLE_SERVICES_CREDIT_CONTROL, 0),\n&gt;&gt;&gt;     (AVP_USED_SERVICE_UNIT, 0),\n&gt;&gt;&gt;     (AVP_CC_TOTAL_OCTETS, 0))\n&gt;&gt;&gt; print(avp[0])\nCC-Total-Octets &lt;Code: 0x1a5, Flags: 0x40 (-M-), Length: 16, Val: 0&gt;\n</code></pre> <p>The search is cached internally, repeating the same find operation will return a cached result.</p> <p>Note</p> <p>Searching for AVPs can be somewhat resource intensive, especially for larger command structures. For messages constructed from received network bytes, it is much cheaper to simply access the values of the message attributes directly. E.g. the example above is the same as:</p> <pre><code>&gt;&gt;&gt; avp = msg.multiple_services_credit_control[0].used_service_unit[0].cc_total_octets\n&gt;&gt;&gt; print(avp[0])\n0\n</code></pre> <p>The method can also be used to search any arbitrary AVP list, by passing an optional keyword argument <code>alt_avps</code>.</p>"},{"location":"api/message/#diameter.message.Message.from_bytes","title":"from_bytes  <code>classmethod</code>","text":"<pre><code>from_bytes(msg_data: bytes, plain_msg: bool = False) -&gt; _AnyMessageType\n</code></pre> <p>Generate a new Message from network received bytes.</p> <p>Accepts a byte string containing received network data and constructs a new <code>Message</code> instance, returning one of its subclasses, if the command code is a known one.</p> <p>If possible, the returned insance is one of the specific subclasses, e.g. <code>CreditControlRequest</code> or <code>CapabilitiesExchangeRequest</code>, which attempt to be as smart as possible and offer direct access to AVPs as class attributes, i.e. <code>CreditControlRequest.session_id</code>. If this is not wanted, the additional keyword argument <code>plain_msg</code> can be set to True, which returns just an instance of <code>Message</code> that holds the list of parsed AVPs and does nothing else.</p> <pre><code>&gt;&gt;&gt; # construct a specific Message with parsed attributes\n&gt;&gt;&gt; ccr = Message.from_bytes(b\"...\")\n&gt;&gt;&gt; ccr.session_id\nlabocs1.gy;379;3434872354\n&gt;&gt;&gt; # construct a plain message with no attribute access\n&gt;&gt;&gt; msg = Message.from_bytes(b\"...\", plain_msg=True)\n&gt;&gt;&gt; # does not work\n&gt;&gt;&gt; msg.session_id\nAttributeError: 'CreditControl' object has no attribute 'session_id'\n&gt;&gt;&gt; # this will work\n&gt;&gt;&gt; session_id = msg.find_avps((AVP_SESSION_ID, 0))[0]\n&gt;&gt;&gt; session_id.value\nlabocs1.gy;379;3434872354\n</code></pre>"},{"location":"api/message/#diameter.message.Message.to_answer","title":"to_answer","text":"<pre><code>to_answer() -&gt; _AnyMessageType\n</code></pre> <p>Produce answer from a request.</p> <p>Copies the request message header to a new answer message, clearing all the flags except the proxyable bit. Attempts to by determine if a suitable python Answer class exists, if not, uses the base class and returns a new instance with the copied header.</p>"},{"location":"api/message/#diameter.message.Message.type_factory","title":"type_factory  <code>classmethod</code>","text":"<pre><code>type_factory(header: MessageHeader) -&gt; Type[_AnyMessageType] | None\n</code></pre> <p>Generate a type that should be used to create new instances.</p> <p>This method is called internally by Message.from_bytes and it can be overridden by inheriting classes to indicate the specific type of message class to generate, e.g. in order to produce different types for \"Request\" and \"Answer\" messages, based on the given header.</p> <p>If no type is returned, the base class type will be used.</p>"},{"location":"api/message/#diameter.message.MessageHeader","title":"MessageHeader","text":"<pre><code>MessageHeader(version: int = 1, length: int = 0, command_flags: int = 0, command_code: int = 0, application_id: int = 0, hop_by_hop_identifier: int = 0, end_to_end_identifier: int = 0)\n</code></pre>"},{"location":"api/message/#diameter.message.DefinedMessage","title":"DefinedMessage","text":"<pre><code>DefinedMessage(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>Message</code></p> <p>A base class for every diameter message that is defined in Python.</p> <p>Every subclass of this class has AVPs defined as python instance attributes, defined based on the diameter base protocol rfc.</p>"},{"location":"api/message/#diameter.message.DefinedMessage.avps","title":"avps  <code>property</code> <code>writable</code>","text":"<pre><code>avps: list[Avp]\n</code></pre> <p>Full list of all AVPs within the message.</p> <p>If the message was generated from network-received bytes, the list of AVPs may not be in the same order as originally received. The returned list of AVPs contains first the AVPs defined by the base rfc6733 spec, if set, followed by any unknown AVPs.</p>"},{"location":"api/message/#diameter.message.DefinedMessage.append_avp","title":"append_avp","text":"<pre><code>append_avp(avp: Avp)\n</code></pre> <p>Add an individual custom AVP.</p>"},{"location":"api/message/#diameter.message.dump","title":"dump","text":"<pre><code>dump(msg: Message) -&gt; str\n</code></pre> <p>Produce a human-readable representation of the given message.</p> <p>Produces a recursive text dump of the given message, its header and all AVPs that it contains. Will work also on unknown AVPs and message command codes; data that is not known to the diameter package is marked with \"Unknown\".</p> <p>Is essentially the same as calling <code>str</code> on the message itself, and then recursively looping through each AVP and calling <code>str(avp)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>Message</code> <p>Any message type</p> required <p>Sample output:</p> <pre><code>Credit-Control &lt;Version: 0x01, Length: 312, Flags: 0x40 (proxyable), Hop-by-Hop Identifier: 0x2711, End-to-End Identifier: 0x4e21&gt;\n  Session-Id &lt;Code: 0x107, Flags: 0x40 (-M-), Length: 73, Val: sctp-saegwc-poz01.lte.orange.pl;221424325;287370797;65574b0c-2d02&gt;\n  Result-Code &lt;Code: 0x10c, Flags: 0x40 (-M-), Length: 12, Val: 2001&gt;\n  Origin-Host &lt;Code: 0x108, Flags: 0x00 (---), Length: 21, Val: b'ocs6.mvno.net'&gt;\n  Origin-Realm &lt;Code: 0x128, Flags: 0x00 (---), Length: 16, Val: b'mvno.net'&gt;\n  Auth-Application-Id &lt;Code: 0x102, Flags: 0x40 (-M-), Length: 12, Val: 4&gt;\n  CC-Request-Type &lt;Code: 0x1a0, Flags: 0x40 (-M-), Length: 12, Val: 2&gt;\n  CC-Request-Number &lt;Code: 0x19f, Flags: 0x40 (-M-), Length: 12, Val: 952&gt;\n  Multiple-Services-Credit-Control &lt;Code: 0x1c8, Flags: 0x40 (-M-), Length: 128&gt;\n    Granted-Service-Unit &lt;Code: 0x1af, Flags: 0x40 (-M-), Length: 24&gt;\n      CC-Total-Octets &lt;Code: 0x1a5, Flags: 0x40 (-M-), Length: 16, Val: 174076000&gt;\n    Rating-Group &lt;Code: 0x1b0, Flags: 0x40 (-M-), Length: 12, Val: 8000&gt;\n    Validity-Time &lt;Code: 0x1c0, Flags: 0x40 (-M-), Length: 12, Val: 3600&gt;\n    Result-Code &lt;Code: 0x10c, Flags: 0x40 (-M-), Length: 12, Val: 2001&gt;\n    Final-Unit-Indication &lt;Code: 0x1ae, Flags: 0x40 (-M-), Length: 44&gt;\n      Final-Unit-Action &lt;Code: 0x1c1, Flags: 0x40 (-M-), Length: 12, Val: 0&gt;\n      Unknown &lt;Code: 0x266e, Flags: 0x80 (V--), Length: 21, Vnd: None, Val: b'TERMINATE'&gt;\n    Quota-Holding-Time &lt;Code: 0x367, Flags: 0xc0 (VM-), Length: 16, Vnd: TGPP, Val: 0&gt;\n</code></pre> <p>Note that:</p> <ul> <li>Message header version, flags and identifiers are as hexadecimal strings</li> <li>AVP flags are shown as three letters, \"VMP\", where \"V\" indicates vendor     specific, \"M\" indicates mandatory and \"P\" indicates private. If a flag     is not set, it is replaced by a \"-\"</li> <li>AVP codes are in hexadecimal</li> <li>Unknown AVPs are rendered, but shown as \"Unknown\"</li> </ul>"},{"location":"api/message_avp/","title":"AVP","text":"<p>API reference for <code>diameter.message.avp</code>.</p>"},{"location":"api/message_avp/#diameter.message.avp.AvpEnumerated","title":"AvpEnumerated  <code>module-attribute</code>","text":"<pre><code>AvpEnumerated = AvpInteger32\n</code></pre> <p>An AVP type that implements the \"Enumerated\". type.</p> <p>As enumeration is a list of valid integer values, is an alias for  AvpInteger32</p>"},{"location":"api/message_avp/#diameter.message.avp.Avp","title":"Avp","text":"<pre><code>Avp(code: int = 0, vendor_id: int = 0, payload: bytes = b'', flags: int = 0)\n</code></pre> <p>A generic AVP type.</p> <p>Represents a single Diameter AVP with (practically) any content. Normally this class should not be instantiated manually at all. If an AVP is to be constructed by hand, it should be done using one of the subclasses, e.g. <code>AvpInteger64</code>, <code>AvpTime</code> etc, as those perform value type conversion, packing and unpacking automatically.</p> <p>In most cases, an AVP should be constructed using the <code>Avp.new</code> factory, that produces a correct AVP type and pre-populates it if necessary, using the <code>AVP_*</code> and <code>VENDOR_*</code> constant values:</p> <pre><code>&gt;&gt;&gt; session_id = Avp.new(constants.AVP_SESSION_ID)\n&gt;&gt;&gt; session_id.value = \"dra.gy.mvno.net;221424325;287370797;65574b0c-2d02\"\n&gt;&gt;&gt; pdp_address = Avp.new(constants.AVP_TGPP_PDP_ADDRESS, constants.VENDOR_TGPP)\n&gt;&gt;&gt; pdp_address.value = \"10.40.93.32\"\n&gt;&gt;&gt; # this has been set automatically\n&gt;&gt;&gt; pdp_address.is_mandatory\nTrue\n</code></pre> <p>AVPs can also be created directly from received network bytes, or from an <code>Unpacker</code> instance that has its position set to the start of an AVP:</p> <pre><code>&gt;&gt;&gt; avp_bytes = bytes.fromhex(\"000001cd40000016333232353140336770702e6f72670000\")\n&gt;&gt;&gt; service_context_id = Avp.from_bytes(avp_bytes)\n&gt;&gt;&gt; str(service_context_id)\nService-Context-Id &lt;Code: 0x1cd, Flags: 0x40 (-M-), Length: 22, Val: 32251@3gpp.org&gt;\n</code></pre> <p>See Avp.from_bytes and Avp.from_unpacker for more details.</p> <p>AVPs have a human-readable <code>str</code> output:</p> <pre><code>&gt;&gt;&gt; input_packets = Avp.new(constants.AVP_ACCT_INPUT_PACKETS, value=17347878)\n&gt;&gt;&gt; str(input_packets)\nAcct-Input-Packets &lt;Code: 0x2f, Flags: 0x00 (---), Length: 12, Val: 17347878&gt;\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>int</code> <p>An AVP code, does not need to be a known code</p> <code>0</code> <code>vendor_id</code> <code>int</code> <p>A vendor ID, or zero if no vendor is set</p> <code>0</code> <code>payload</code> <code>bytes</code> <p>An optional AVP payload to initialise the AVP with. Must be a properly encoded value that matches the type of AVP.</p> <code>b''</code> <code>flags</code> <code>int</code> <p>An optional integer value for the AVP flags</p> <code>0</code>"},{"location":"api/message_avp/#diameter.message.avp.Avp.code","title":"code  <code>instance-attribute</code>","text":"<pre><code>code: int = code\n</code></pre> <p>AVP code. Corresponds to <code>AVP_*</code> constant values.</p>"},{"location":"api/message_avp/#diameter.message.avp.Avp.flags","title":"flags  <code>instance-attribute</code>","text":"<pre><code>flags: int = flags\n</code></pre> <p>AVP flags. These should not be set manually, refer to <code>is_mandatory</code>, <code>is_private</code> and <code>vendor_id</code>. The flags are updated automatically as  these properties are changed.</p>"},{"location":"api/message_avp/#diameter.message.avp.Avp.is_mandatory","title":"is_mandatory  <code>property</code> <code>writable</code>","text":"<pre><code>is_mandatory: bool\n</code></pre> <p>Indicates if the mandatory (M) flag is set, or sets it.</p>"},{"location":"api/message_avp/#diameter.message.avp.Avp.is_private","title":"is_private  <code>property</code> <code>writable</code>","text":"<pre><code>is_private: bool\n</code></pre> <p>Indicates if the private (P) flag is set, or sets it.</p>"},{"location":"api/message_avp/#diameter.message.avp.Avp.is_vendor","title":"is_vendor  <code>property</code>","text":"<pre><code>is_vendor: bool\n</code></pre> <p>Indicates if the AVP is vendor-specific (has non-zero vendor_id).</p>"},{"location":"api/message_avp/#diameter.message.avp.Avp.length","title":"length  <code>property</code>","text":"<pre><code>length\n</code></pre> <p>The entire length of the AVP, including header and vendor bit.</p>"},{"location":"api/message_avp/#diameter.message.avp.Avp.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str = 'Unknown'\n</code></pre> <p>The name of the AVP, e.g. \"Session-Id\". Not unique in any way.</p>"},{"location":"api/message_avp/#diameter.message.avp.Avp.payload","title":"payload  <code>instance-attribute</code>","text":"<pre><code>payload: bytes = payload\n</code></pre> <p>The actual AVP payload as encoded bytes. This should not be set  directly; the <code>value</code> property should be changed instead, which will  automatically encode the payload correctly based on the type of the  AVP.</p>"},{"location":"api/message_avp/#diameter.message.avp.Avp.value","title":"value  <code>property</code> <code>writable</code>","text":"<pre><code>value: Any\n</code></pre> <p>The actual AVP value. When altered, the AVP instance encodes and decodes the property accordingly, and alters its <code>payload</code> property.</p>"},{"location":"api/message_avp/#diameter.message.avp.Avp.vendor_id","title":"vendor_id  <code>property</code> <code>writable</code>","text":"<pre><code>vendor_id: int\n</code></pre> <p>The current vendor ID. When modified, the AVP flags are also automatically updated with the vendor set bit.</p>"},{"location":"api/message_avp/#diameter.message.avp.Avp.as_bytes","title":"as_bytes","text":"<pre><code>as_bytes() -&gt; bytes\n</code></pre> <p>Retrieve a byte-encoded AVP, including its header.</p>"},{"location":"api/message_avp/#diameter.message.avp.Avp.as_packed","title":"as_packed","text":"<pre><code>as_packed(packer: Packer) -&gt; Packer\n</code></pre> <p>Append AVP byte-encoded contents, into a Packer instance.</p> <p>Parameters:</p> Name Type Description Default <code>packer</code> <code>Packer</code> <p>A packer instance, where the AVP contents are appended to, including its header</p> required <p>Returns:</p> Type Description <code>Packer</code> <p>The modified packer instance.</p>"},{"location":"api/message_avp/#diameter.message.avp.Avp.from_avp","title":"from_avp  <code>classmethod</code>","text":"<pre><code>from_avp(another_avp: _AnyAvpType) -&gt; _AnyAvpType\n</code></pre> <p>Create a copy based on another AVP.</p> <p>Encodes the given AVP into bytes, then constructs a new AVP instance using <code>Avp.from_bytes</code>.</p> <p>Parameters:</p> Name Type Description Default <code>another_avp</code> <code>_AnyAvpType</code> <p>The AVP to copy.</p> required <p>Returns:</p> Type Description <code>_AnyAvpType</code> <p>A new AVP instance with data identical to the copy.</p>"},{"location":"api/message_avp/#diameter.message.avp.Avp.from_bytes","title":"from_bytes  <code>classmethod</code>","text":"<pre><code>from_bytes(avp_data: bytes) -&gt; _AnyAvpType\n</code></pre> <p>Create new AVP from network received bytes.</p> <p>Accepts byte strings and returns a python representation of the contents.</p> <pre><code>&gt;&gt;&gt; avp_bytes = bytes.fromhex(\"000001cd40000016333232353140336770702e6f72670000\")\n&gt;&gt;&gt; a = avp.Avp.from_bytes(avp_bytes)\n&gt;&gt;&gt;\n&gt;&gt;&gt; assert a.code == 461\n&gt;&gt;&gt; assert a.is_mandatory is True\n&gt;&gt;&gt; assert a.is_private is False\n&gt;&gt;&gt; assert a.is_vendor is False\n&gt;&gt;&gt; assert a.length == 22\n&gt;&gt;&gt; assert a.value == \"32251@3gpp.org\"\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>avp_data</code> <code>bytes</code> <p>Any network-received bytes that starts at an AVP boundary. May contain more than one AVP; the byte string is consumed until one full AVP has been decoded and the rest is discarded.</p> required"},{"location":"api/message_avp/#diameter.message.avp.Avp.from_unpacker","title":"from_unpacker  <code>classmethod</code>","text":"<pre><code>from_unpacker(unpacker: Unpacker) -&gt; _AnyAvpType\n</code></pre> <p>Create a new AVP from an Unpacker instance.</p> <p>Parameters:</p> Name Type Description Default <code>unpacker</code> <code>Unpacker</code> <p>An instance of Unpacker that has its buffer set to a position where an AVP begins.</p> required <p>Returns:</p> Type Description <code>_AnyAvpType</code> <p>A new AVP. The position of the unpacker is set at the end of the AVP byte stream.</p>"},{"location":"api/message_avp/#diameter.message.avp.Avp.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(avp_code: int, vendor_id: int = 0, value: str | int | float | bytes | list | datetime.datetime = None, is_mandatory: bool = None, is_private: bool = None) -&gt; _AnyAvpType\n</code></pre> <p>Generates a new AVP.</p> <p>The preferred way to build a new AVP. Returns an AVP that has a type that matches the AVP code, e.g. <code>AVP_ACCT_INPUT_PACKETS</code> would return an \"Acct-Input_packets\" AVP, as an instance of <code>AvpInteger32</code>.</p> <p>Parameters:</p> Name Type Description Default <code>avp_code</code> <code>int</code> <p>An AVP code or one of the <code>AVP_*</code> constants</p> required <code>vendor_id</code> <code>int</code> <p>A known vendor ID, must be set if a vendor-specific AVP is to be built</p> <code>0</code> <code>value</code> <code>str | int | float | bytes | list | datetime</code> <p>An optional AVP value. If not given, will also not set any value, which may be an invalid operation for the AVP. A value can be set later by assigning a value to the <code>value</code> attribute. If given, the value must be valid for the type of AVP being created. E.g. an \"Integer32\" AVP must have a 32-bit integer as its value, a \"Grouped\" AVP must have a list of AVPs as its value, etc.</p> <code>None</code> <code>is_mandatory</code> <code>bool</code> <p>Optionally sets or unsets the mandatory flag manually. If not given, detaults to setting the flag based on whatever was defined in the dictionary originally</p> <code>None</code> <code>is_private</code> <code>bool</code> <p>Optionally sets or unsets the private flag. Default is to leave the flag untouched</p> <code>None</code>"},{"location":"api/message_avp/#diameter.message.avp.AvpAddress","title":"AvpAddress","text":"<pre><code>AvpAddress(code: int = 0, vendor_id: int = 0, payload: bytes = b'', flags: int = 0)\n</code></pre> <p>             Bases: <code>Avp</code></p> <p>An AVP type that implements \"Address\".</p> <p>According to <code>rfc677</code>, an Address format is derived from the OctetString format and represents usually an IPv4 or an IPv6 address, or an E.164 subscriber ID. The format contains both the value and the address family defined by IANAADFAM.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>int</code> <p>An AVP code, does not need to be a known code</p> <code>0</code> <code>vendor_id</code> <code>int</code> <p>A vendor ID, or zero if no vendor is set</p> <code>0</code> <code>payload</code> <code>bytes</code> <p>An optional AVP payload to initialise the AVP with. Must be a properly encoded value that matches the type of AVP.</p> <code>b''</code> <code>flags</code> <code>int</code> <p>An optional integer value for the AVP flags</p> <code>0</code>"},{"location":"api/message_avp/#diameter.message.avp.AvpAddress.value","title":"value  <code>property</code> <code>writable</code>","text":"<pre><code>value: tuple[int, str]\n</code></pre> <p>The address family and its value. When reading, always returns a tuple containing the address family and a string representation of the actual address. Currently implemented address families are:</p> <ul> <li>1: IP version 4</li> <li>2: IP version 6</li> <li>8: E.164</li> </ul> <p>When setting a new value, only the actual string value should be set, the address family is determined automatically. E.g.:</p> <pre><code>&gt;&gt;&gt; addr = AvpAddress()\n&gt;&gt;&gt; addr.value = \"10.0.0.1\"\n&gt;&gt;&gt; addr.value\n(1, '10.0.0.1')\n&gt;&gt;&gt; addr.value = \"41780009999\"\n&gt;&gt;&gt; addr.value\n(8, '41780009999')\n</code></pre> <p>If the value to be set cannot be parsed as a valid IPv4 or an IPv6 address, the address family is automatically set to E.164.</p>"},{"location":"api/message_avp/#diameter.message.avp.AvpDecodeError","title":"AvpDecodeError","text":"<p>             Bases: <code>Exception</code></p> <p>An exception raised when an AVP value contains data that cannot be decoded into a python type.</p>"},{"location":"api/message_avp/#diameter.message.avp.AvpEncodeError","title":"AvpEncodeError","text":"<p>             Bases: <code>Exception</code></p> <p>An exception raised when a value of an AVP has been set to something that the AVP type cannot encode.</p>"},{"location":"api/message_avp/#diameter.message.avp.AvpFloat32","title":"AvpFloat32","text":"<pre><code>AvpFloat32(code: int = 0, vendor_id: int = 0, payload: bytes = b'', flags: int = 0)\n</code></pre> <p>             Bases: <code>Avp</code></p> <p>An AVP type that implements \"Float32\".</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>int</code> <p>An AVP code, does not need to be a known code</p> <code>0</code> <code>vendor_id</code> <code>int</code> <p>A vendor ID, or zero if no vendor is set</p> <code>0</code> <code>payload</code> <code>bytes</code> <p>An optional AVP payload to initialise the AVP with. Must be a properly encoded value that matches the type of AVP.</p> <code>b''</code> <code>flags</code> <code>int</code> <p>An optional integer value for the AVP flags</p> <code>0</code>"},{"location":"api/message_avp/#diameter.message.avp.AvpFloat32.value","title":"value  <code>property</code> <code>writable</code>","text":"<pre><code>value: float\n</code></pre> <p>AVP value as a python float. When setting the value, it must be a 32-bit integer. Larger intergers will raise an <code>AvpEncodeError</code>.</p>"},{"location":"api/message_avp/#diameter.message.avp.AvpFloat64","title":"AvpFloat64","text":"<pre><code>AvpFloat64(code: int = 0, vendor_id: int = 0, payload: bytes = b'', flags: int = 0)\n</code></pre> <p>             Bases: <code>Avp</code></p> <p>An AVP type that implements \"Float64\".</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>int</code> <p>An AVP code, does not need to be a known code</p> <code>0</code> <code>vendor_id</code> <code>int</code> <p>A vendor ID, or zero if no vendor is set</p> <code>0</code> <code>payload</code> <code>bytes</code> <p>An optional AVP payload to initialise the AVP with. Must be a properly encoded value that matches the type of AVP.</p> <code>b''</code> <code>flags</code> <code>int</code> <p>An optional integer value for the AVP flags</p> <code>0</code>"},{"location":"api/message_avp/#diameter.message.avp.AvpFloat64.value","title":"value  <code>property</code> <code>writable</code>","text":"<pre><code>value: float\n</code></pre> <p>AVP value as a python float. When setting the value, it must be a 64-bit integer. Larger numbers will raise an <code>AvpEncodeError</code>.</p>"},{"location":"api/message_avp/#diameter.message.avp.AvpGrouped","title":"AvpGrouped","text":"<pre><code>AvpGrouped(code: int = 0, vendor_id: int = 0, payload: bytes = b'', flags: int = 0)\n</code></pre> <p>             Bases: <code>Avp</code></p> <p>An AVP type that implements \"Grouped\".</p> <p>The \"Grouped\" AVP contains a sequence of AVPs. The actual AVP payload consists of a concatenated byte stream of individual AVPs, containing also their headers. The python value is represented as a <code>list</code> of <code>Avp</code> instances.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>int</code> <p>An AVP code, does not need to be a known code</p> <code>0</code> <code>vendor_id</code> <code>int</code> <p>A vendor ID, or zero if no vendor is set</p> <code>0</code> <code>payload</code> <code>bytes</code> <p>An optional AVP payload to initialise the AVP with. Must be a properly encoded value that matches the type of AVP.</p> <code>b''</code> <code>flags</code> <code>int</code> <p>An optional integer value for the AVP flags</p> <code>0</code>"},{"location":"api/message_avp/#diameter.message.avp.AvpGrouped.value","title":"value  <code>property</code> <code>writable</code>","text":"<pre><code>value: list[_AnyAvpType]\n</code></pre> <p>Set or read the list of grouped AVPs. The actual AVPs contained within are not decoded until the value is read for the first time. Once read, the value is cached internally and will not change, unless the entire AVP list is overwritten.</p> <p>When setting a value, it must be set to an entire list of AVPs:</p> <pre><code>&gt;&gt;&gt; grp = AvpGrouped()\n&gt;&gt;&gt; grp.value = [AvpOctetString(), AvpOctetString()]\n</code></pre> <p>Alternatively, the value can be operated as a regular list:</p> <pre><code>&gt;&gt;&gt; grp = AvpGrouped()\n&gt;&gt;&gt; grp.value.append(AvpOctetString())\n</code></pre>"},{"location":"api/message_avp/#diameter.message.avp.AvpInteger32","title":"AvpInteger32","text":"<pre><code>AvpInteger32(code: int = 0, vendor_id: int = 0, payload: bytes = b'', flags: int = 0)\n</code></pre> <p>             Bases: <code>Avp</code></p> <p>An AVP type that implements the \"Integer32\" type.</p> <p>The \"Integer32\" type has a 32-bit signed value.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>int</code> <p>An AVP code, does not need to be a known code</p> <code>0</code> <code>vendor_id</code> <code>int</code> <p>A vendor ID, or zero if no vendor is set</p> <code>0</code> <code>payload</code> <code>bytes</code> <p>An optional AVP payload to initialise the AVP with. Must be a properly encoded value that matches the type of AVP.</p> <code>b''</code> <code>flags</code> <code>int</code> <p>An optional integer value for the AVP flags</p> <code>0</code>"},{"location":"api/message_avp/#diameter.message.avp.AvpInteger32.value","title":"value  <code>property</code> <code>writable</code>","text":"<pre><code>value: int\n</code></pre> <p>Sets or retrieves the AVP value as a python integer. When setting the value, it must be a 32-bit integer. Larger integers will raise an <code>AvpEncodeError</code>.</p>"},{"location":"api/message_avp/#diameter.message.avp.AvpInteger64","title":"AvpInteger64","text":"<pre><code>AvpInteger64(code: int = 0, vendor_id: int = 0, payload: bytes = b'', flags: int = 0)\n</code></pre> <p>             Bases: <code>Avp</code></p> <p>An AVP type that implements the \"Integer64\" type.</p> <p>The \"Integer64\" type has a 64-bit signed value.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>int</code> <p>An AVP code, does not need to be a known code</p> <code>0</code> <code>vendor_id</code> <code>int</code> <p>A vendor ID, or zero if no vendor is set</p> <code>0</code> <code>payload</code> <code>bytes</code> <p>An optional AVP payload to initialise the AVP with. Must be a properly encoded value that matches the type of AVP.</p> <code>b''</code> <code>flags</code> <code>int</code> <p>An optional integer value for the AVP flags</p> <code>0</code>"},{"location":"api/message_avp/#diameter.message.avp.AvpInteger64.value","title":"value  <code>property</code> <code>writable</code>","text":"<pre><code>value: int\n</code></pre> <p>Sets or retrieves the AVP value as a python integer. When setting the value, it must be a 64-bit integer. Larger integers will raise an <code>AvpEncodeError</code>.</p>"},{"location":"api/message_avp/#diameter.message.avp.AvpOctetString","title":"AvpOctetString","text":"<pre><code>AvpOctetString(code: int = 0, vendor_id: int = 0, payload: bytes = b'', flags: int = 0)\n</code></pre> <p>             Bases: <code>Avp</code></p> <p>An AVP type that implements the \"OctetString\" type.</p> <p>The \"OctetString\" type contains arbitrary data of variable length.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>int</code> <p>An AVP code, does not need to be a known code</p> <code>0</code> <code>vendor_id</code> <code>int</code> <p>A vendor ID, or zero if no vendor is set</p> <code>0</code> <code>payload</code> <code>bytes</code> <p>An optional AVP payload to initialise the AVP with. Must be a properly encoded value that matches the type of AVP.</p> <code>b''</code> <code>flags</code> <code>int</code> <p>An optional integer value for the AVP flags</p> <code>0</code>"},{"location":"api/message_avp/#diameter.message.avp.AvpOctetString.value","title":"value  <code>property</code> <code>writable</code>","text":"<pre><code>value: bytes\n</code></pre> <p>Sets or retrieves the AVP value, as python bytes. When setting the value, it must be bytes. Any other type will raise an <code>AvpEncodeError</code>.</p>"},{"location":"api/message_avp/#diameter.message.avp.AvpTime","title":"AvpTime","text":"<pre><code>AvpTime(code: int = 0, vendor_id: int = 0, payload: bytes = b'', flags: int = 0)\n</code></pre> <p>             Bases: <code>Avp</code></p> <p>An AVP type that implements the \"Time\" type.</p> <p>According to <code>rfc677</code>, a Time format is derived from the OctetString basic AVP format. It contains four octets, in the same format as the first four bytes are in the NTP timestamp format, defined in <code>rfc5905</code>.</p> <p>The octets represent the number of seconds since 0h on 1 January 1900, in UTC. This value will overflow at 6h 28m 16s UTC, 7 February 2036.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>int</code> <p>An AVP code, does not need to be a known code</p> <code>0</code> <code>vendor_id</code> <code>int</code> <p>A vendor ID, or zero if no vendor is set</p> <code>0</code> <code>payload</code> <code>bytes</code> <p>An optional AVP payload to initialise the AVP with. Must be a properly encoded value that matches the type of AVP.</p> <code>b''</code> <code>flags</code> <code>int</code> <p>An optional integer value for the AVP flags</p> <code>0</code>"},{"location":"api/message_avp/#diameter.message.avp.AvpTime.value","title":"value  <code>property</code> <code>writable</code>","text":"<pre><code>value: datetime.datetime\n</code></pre> <p>Sets or retrieves the AVP value, as an instance of python datetime. When setting the value, it must be an instance of datetime. Any other data type, or if the datetime instance contains an unsupported value, will raise an <code>AvpEncodeError</code>.</p>"},{"location":"api/message_avp/#diameter.message.avp.AvpUnsigned32","title":"AvpUnsigned32","text":"<pre><code>AvpUnsigned32(code: int = 0, vendor_id: int = 0, payload: bytes = b'', flags: int = 0)\n</code></pre> <p>             Bases: <code>Avp</code></p> <p>An AVP type that implements the \"Unsigned32\" type.</p> <p>The \"Unsigned32\" type has a 32-bit unsigned value.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>int</code> <p>An AVP code, does not need to be a known code</p> <code>0</code> <code>vendor_id</code> <code>int</code> <p>A vendor ID, or zero if no vendor is set</p> <code>0</code> <code>payload</code> <code>bytes</code> <p>An optional AVP payload to initialise the AVP with. Must be a properly encoded value that matches the type of AVP.</p> <code>b''</code> <code>flags</code> <code>int</code> <p>An optional integer value for the AVP flags</p> <code>0</code>"},{"location":"api/message_avp/#diameter.message.avp.AvpUnsigned32.value","title":"value  <code>property</code> <code>writable</code>","text":"<pre><code>value: int\n</code></pre> <p>Sets or retrieves the AVP value as a python integer. When setting the value, it must be a 32-bit unsigned integer. Larger and signed integers will raise an <code>AvpEncodeError</code>.</p>"},{"location":"api/message_avp/#diameter.message.avp.AvpUnsigned64","title":"AvpUnsigned64","text":"<pre><code>AvpUnsigned64(code: int = 0, vendor_id: int = 0, payload: bytes = b'', flags: int = 0)\n</code></pre> <p>             Bases: <code>Avp</code></p> <p>An AVP type that implements the \"Unsigned64\" type.</p> <p>The \"Unsigned64\" type has a 64-bit unsigned value.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>int</code> <p>An AVP code, does not need to be a known code</p> <code>0</code> <code>vendor_id</code> <code>int</code> <p>A vendor ID, or zero if no vendor is set</p> <code>0</code> <code>payload</code> <code>bytes</code> <p>An optional AVP payload to initialise the AVP with. Must be a properly encoded value that matches the type of AVP.</p> <code>b''</code> <code>flags</code> <code>int</code> <p>An optional integer value for the AVP flags</p> <code>0</code>"},{"location":"api/message_avp/#diameter.message.avp.AvpUnsigned64.value","title":"value  <code>property</code> <code>writable</code>","text":"<pre><code>value: int\n</code></pre> <p>Sets or retrieves the AVP value as a python integer. When setting the value, it must be a 64-bit unsigned integer. Larger and signed integers will raise an <code>AvpEncodeError</code>.</p>"},{"location":"api/message_avp/#diameter.message.avp.AvpUtf8String","title":"AvpUtf8String","text":"<pre><code>AvpUtf8String(code: int = 0, vendor_id: int = 0, payload: bytes = b'', flags: int = 0)\n</code></pre> <p>             Bases: <code>Avp</code></p> <p>An AVP type that implements the \"UTF8String\" type.</p> <p>According to <code>rfc677</code>, a UTF8String format is derived from the OctetString basic AVP format. It is defined as a human-readable string represented using the ISO/IEC IS 10646-1 character set, encoded as an OctetString using the UTF-8 transformation format. It translates to the basic python <code>str</code> type.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>int</code> <p>An AVP code, does not need to be a known code</p> <code>0</code> <code>vendor_id</code> <code>int</code> <p>A vendor ID, or zero if no vendor is set</p> <code>0</code> <code>payload</code> <code>bytes</code> <p>An optional AVP payload to initialise the AVP with. Must be a properly encoded value that matches the type of AVP.</p> <code>b''</code> <code>flags</code> <code>int</code> <p>An optional integer value for the AVP flags</p> <code>0</code>"},{"location":"api/message_avp/#diameter.message.avp.AvpUtf8String.value","title":"value  <code>property</code> <code>writable</code>","text":"<pre><code>value: str\n</code></pre> <p>Sets or retrieves the AVP value, as a python str. When setting the value, it must be a string that can be encoded as utf-8. Any other data type, or strings that will not encode as utf-8, will raise an <code>AvpEncodeError</code>.</p>"},{"location":"api/node/","title":"Node","text":"<p>API reference for <code>diameter.node</code>.</p>"},{"location":"api/node/#diameter.node.Node","title":"Node","text":"<pre><code>Node(origin_host: str, realm_name: str, ip_addresses: list[str] = None, tcp_port: int = None, sctp_port: int = None, vendor_ids: list[int] = None)\n</code></pre> <p>A diameter node.</p> <p>A single diameter node represents the local peer. It handles connections to other peers, exchanging capabilities-exchange, device-watchdog and disconnect-peer requests and answers on its own.</p> <p>The node can act either as a server or as a client. In both cases it will handle both incoming and outgoing requests, however when acting as a client, other diameter nodes cannot connect to it, all connections must be initiated and managed by the client. When acting as a server, connections can be established by any party.</p> <p>The node supports both TCP and SCTP transport modes. When acting as a server, it can always listen on multiple addresses, however this is only useful when utilising SCTP, as other peers will only connect to a single TCP address at a time.</p> <p>The node can connect to multiple peers simultaneously; peers can be added using <code>Node.add_peer</code>. Both TCP and SCTP transport modes are accepted and can be mixed at will. Peers can be flagged as persistent, in which case the Node will periodically attempt to reconnect, if a connection is lost.</p> <pre><code>&gt;&gt;&gt; node = Node()\n&gt;&gt;&gt; node.add_peer(\"aaa://dra1.gy:3868;transport=tcp\", \"realm.net\", [\"10.16.17.5\"])\n&gt;&gt;&gt; node.add_peer(\"aaa://dra2.gy;transport=sctp\", \"realm.net\", [\"10.16.17.6\", \"172.16.0.6\"])\n&gt;&gt;&gt; node.start()\n</code></pre> <p>Any other message than CER/CEA, DWR/DWA and DPR/DPA will be routed to a diameter application that is expected to do the actual work. Applications can be created by subclassing either diameter.node.application.Application or diameter.node.application.ThreadingApplication and adding them to this node using add_application. If a message is received that is intended for an application that does not exist, a diameter error is returned to the peer.</p> <p>Outgoing requests are routed based on realm and peer routing tables; if a request does not contain the Destination-Host AVP, the request is forwarded to a peer that has a matching realm and application ID set. If multiple peers are available, a rudimentary load balancing based on least used connections is used. Answers are routed back to the peer that they originated from, or dropped if the peer has gone away.</p> <p>Parameters:</p> Name Type Description Default <code>origin_host</code> <code>str</code> <p>Our local node FQDN, must include the realm</p> required <code>realm_name</code> <code>str</code> <p>Realm FQDN</p> required <code>ip_addresses</code> <code>list[str]</code> <p>An optional list of IP address that the node will listen on for incoming requests. Must be set if the node is to act as a server. When not set, the node will not listen for any incoming connection attempts.</p> <code>None</code> <code>tcp_port</code> <code>int</code> <p>An optional TCP listen port, should be set if <code>ip_addresses</code> is set, defaults to 3868 if nothing is given</p> <code>None</code> <code>sctp_port</code> <code>int</code> <p>An optional SCTP listen port, should be set if <code>ip_addresses</code> is set, defaults to 3868 if nothing is given</p> <code>None</code> <code>vendor_ids</code> <code>list[int]</code> <p>List of supported vendor IDs. If not set, will default to all known vendor IDs. The list of vendor IDs is only used in advertising the node's capabilities in  CER/CEA</p> <code>None</code>"},{"location":"api/node/#diameter.node.Node.applications","title":"applications  <code>instance-attribute</code>","text":"<pre><code>applications: list[Application] = []\n</code></pre> <p>List of configured applications.</p>"},{"location":"api/node/#diameter.node.Node.cea_timeout","title":"cea_timeout  <code>instance-attribute</code>","text":"<pre><code>cea_timeout: int = 4\n</code></pre> <p>Default timeout waiting for a CEA after sending a CER, in seconds. Will be used if no specific timeout value has been configured for a  peer.</p>"},{"location":"api/node/#diameter.node.Node.cer_timeout","title":"cer_timeout  <code>instance-attribute</code>","text":"<pre><code>cer_timeout: int = 4\n</code></pre> <p>Default timeout waiting for a CER after receiving a connection  attempt, in seconds. Will be used if no specific timeout value has been  configured for a peer</p>"},{"location":"api/node/#diameter.node.Node.connections","title":"connections  <code>instance-attribute</code>","text":"<pre><code>connections: dict[str, PeerConnection] = {}\n</code></pre> <p>Currently handled peer connections.</p>"},{"location":"api/node/#diameter.node.Node.dwa_timeout","title":"dwa_timeout  <code>instance-attribute</code>","text":"<pre><code>dwa_timeout: int = 4\n</code></pre> <p>Default timeout waiting for a DWA after sending a DWR, in seconds.  Will be used if no specific timeout value has been configured for a  peer.</p>"},{"location":"api/node/#diameter.node.Node.end_to_end_seq","title":"end_to_end_seq  <code>instance-attribute</code>","text":"<pre><code>end_to_end_seq = SequenceGenerator(self.state_id)\n</code></pre> <p>An end-to-end identifier generator. The next identifier can be  retrieved with <code>Node.end_to_end_seq.next_sequence()</code>.</p>"},{"location":"api/node/#diameter.node.Node.idle_timeout","title":"idle_timeout  <code>instance-attribute</code>","text":"<pre><code>idle_timeout: int = 30\n</code></pre> <p>Default time spent idle before a DWR is triggered, in seconds.  Will be used if no specific timeout value has been configured for a  peer.</p>"},{"location":"api/node/#diameter.node.Node.peer_sockets","title":"peer_sockets  <code>instance-attribute</code>","text":"<pre><code>peer_sockets: dict[str, socket.socket | sctp.sctpsocket] = {}\n</code></pre> <p>Currently held sockets, one for each peer connection.</p>"},{"location":"api/node/#diameter.node.Node.peers","title":"peers  <code>instance-attribute</code>","text":"<pre><code>peers: dict[str, Peer] = {}\n</code></pre> <p>All currently known peers as a dictionary of host identities as  keys and instances of <code>Peer</code> as values..</p>"},{"location":"api/node/#diameter.node.Node.product_name","title":"product_name  <code>instance-attribute</code>","text":"<pre><code>product_name: str = 'python-diameter'\n</code></pre> <p>Our product name.</p>"},{"location":"api/node/#diameter.node.Node.session_generator","title":"session_generator  <code>instance-attribute</code>","text":"<pre><code>session_generator = SessionGenerator(self.origin_host)\n</code></pre> <p>A unique diameter session ID generator. The next unique session  ID can be retrieved <code>Node.session_generator.next_id()</code>.</p>"},{"location":"api/node/#diameter.node.Node.socket_peers","title":"socket_peers  <code>instance-attribute</code>","text":"<pre><code>socket_peers: dict[int, PeerConnection] = {}\n</code></pre> <p>Peer connection lookup based on socket fileno.</p>"},{"location":"api/node/#diameter.node.Node.vendor_id","title":"vendor_id  <code>instance-attribute</code>","text":"<pre><code>vendor_id: int = 99999\n</code></pre> <p>Our vendor ID. Defaults to \"unknown\".</p>"},{"location":"api/node/#diameter.node.Node.wakeup_interval","title":"wakeup_interval  <code>instance-attribute</code>","text":"<pre><code>wakeup_interval: int = 6\n</code></pre> <p>Time in seconds between forced wakeups while waiting for connection sockets to become active. This timer value controls how often peer  timers are checked, how often reconnects are attempted and how often  statistics are dumped in the logfiles. </p> <p>As this also defines the interval at which peer timers are checked, it  is also the smallest possible value for a peer timer value. Setting  this value very low will consume more CPU, setting it too high will  make observing short timeouts impossible.</p> <p>This value also defines how long a node will continue to run, after  <code>stop</code> with <code>force</code> argument set to <code>True</code> is called.</p>"},{"location":"api/node/#diameter.node.Node.add_application","title":"add_application","text":"<pre><code>add_application(app: Application, peers: list[Peer])\n</code></pre> <p>Register an application with diameter node.</p> <p>The added application will receive diameter requests that the node receives, which an application-id message header value matching the application's ID.</p> <p>When added, the node calls the application's <code>start</code> method immediately. The application is stopped when the node stops.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>Application</code> <p>An instance of a class that implements <code>Application</code></p> required <code>peers</code> <code>list[Peer]</code> <p>A list of Peer instances that have been returned by <code>Node.add_peer</code>. The given list of peers will be used to determine how messages are to be routed</p> required"},{"location":"api/node/#diameter.node.Node.add_peer","title":"add_peer","text":"<pre><code>add_peer(peer_uri: str, realm_name: str = None, ip_addresses: list[str] = None, is_persistent: bool = False, is_default: bool = False) -&gt; Peer\n</code></pre> <p>Add a known peer.</p> <p>The node will only connect to known connections and (optionally) accept requests from known connections only.</p> <p>Parameters:</p> Name Type Description Default <code>peer_uri</code> <code>str</code> <p>A diameter node's DiameterIdentity as a DiameterURI string, i.e. \"aaa://:;transport=\". The URI must contain at least the scheme and FQDN; the port and transport will default to 3868 and \"TCP\" if not included required <code>realm_name</code> <code>str</code> <p>Peer realm name. If not given, will be set to the same realm as the node has been configured with</p> <code>None</code> <code>ip_addresses</code> <code>list[str]</code> <p>A list of IP addresses for the peer. If not given, no outgoing connection attempt to the peer will be made. For TCP, only the first IP of the list is used. For SCTP, a connection will be established to every address</p> <code>None</code> <code>is_persistent</code> <code>bool</code> <p>Enable persistent connection to the peer. If enabled, the node will automatically re-establish a connection to the peer on startup and at connection loss</p> <code>False</code> <code>is_default</code> <code>bool</code> <p>Set this peer as the default peer for the realm. Note that multiple defaults is permitted. Setting multiple pers as default will result in load balancing between the peers.</p> <code>False</code> <p>Returns:</p> Type Description <code>Peer</code> <p>An instance of the peer. The returned instance is the actual peer instance, permitting configuration to be adjusted after node has been started, by altering its attributes.</p>"},{"location":"api/node/#diameter.node.Node.close_connection_socket","title":"close_connection_socket","text":"<pre><code>close_connection_socket(conn: PeerConnection)\n</code></pre> <p>Shuts down connection socket and stops observing it forever.</p> <p>If the corresponding peer has persistency enabled, the node will automatically re-establish the connection after <code>Node.reconnect_timeout</code> seconds.</p> <p>Closing the peer socket will automatically call <code>Node.remove_peer_connection</code>.</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>PeerConnection</code> <p>An instance of a peer connection to disconnect</p> required"},{"location":"api/node/#diameter.node.Node.remove_peer_connection","title":"remove_peer_connection","text":"<pre><code>remove_peer_connection(conn: PeerConnection)\n</code></pre> <p>Removes a peer connection that is no longer connected.</p> <p>Warning</p> <p>This method should not be called directly, unless it is absolutely certain that the peer socket is no longer connected. The safer way is to use <code>Node.close_connection_socket</code> instead, which will first close the socket and then remove the peer.</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>PeerConnection</code> <p>An instance of peer connection to remove from the list of active connections</p> required"},{"location":"api/node/#diameter.node.Node.route_answer","title":"route_answer","text":"<pre><code>route_answer(message: Message) -&gt; tuple[PeerConnection, Message]\n</code></pre> <p>Determine which peer should be used for sending an answer message.</p> <p>Should always be used by an application before sending an answer.</p> <p>Determines the proper peer to be used, by keeping track of which requests have been sent, and always forwarding answers in reverse direction to correct peer connections.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Message</code> <p>The exact answer message to send</p> required <p>Returns:</p> Type Description <code>tuple[PeerConnection, Message]</code> <p>A tuple with an instance of a peer to route to, and the same message as was passed to the method.</p> <p>Raises:</p> Type Description <code>NotRoutable</code> <p>when there is either no peer waiting for the answer, or when the peer exists, but does not accept messages at the time</p>"},{"location":"api/node/#diameter.node.Node.route_request","title":"route_request","text":"<pre><code>route_request(app: Application, message: Message) -&gt; tuple[PeerConnection, Message]\n</code></pre> <p>Determine which peer should be used for sending a request message.</p> <p>Should always be used by an application before sending a request.</p> <p>Determines the proper peer to be used for the particular message, by comparing the configured peer list with what is currently connected and ready to receive requests. If multiple connections are available, a rudimentary load balancing is used, with least-used peer selected.</p> <p>Sets the hop-by-hop identifier automatically based on the selected peer.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>Application</code> <p>The application instance that wants to send a request</p> required <code>message</code> <code>Message</code> <p>The exact message to send</p> required <p>Returns:</p> Type Description <code>tuple[PeerConnection, Message]</code> <p>A tuple with an instance of a peer to route to, and the same message as was passed to the method.</p> <p>Raises:</p> Type Description <code>NotRoutable</code> <p>when there is either no connections configured for the application, or if none of the configured connections is connected or accepting requests at the time</p>"},{"location":"api/node/#diameter.node.Node.send_message","title":"send_message","text":"<pre><code>send_message(conn: PeerConnection, message: Message)\n</code></pre> <p>Manually send a message towards a peer.</p> <p>Normally messages are sent through applications, but this method permits manually sending messages towards known connections.</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>PeerConnection</code> <p>An instance of a peer to send the message to. The peer must be in <code>PEER_READY</code> or <code>PEER_READY_WAITING_DWA</code> state</p> required <code>message</code> <code>Message</code> <p>A valid diameter message instance to send</p> required"},{"location":"api/node/#diameter.node.Node.start","title":"start","text":"<pre><code>start()\n</code></pre> <p>Start the node.</p> <p>This method must be called once after the peer has been created. At startup, the node will create the local listening sockets, start its work threads and connect to any connections that have persistent connections enabled.</p>"},{"location":"api/node/#diameter.node.Node.stop","title":"stop","text":"<pre><code>stop(wait_timeout: int = 180, force: bool = False)\n</code></pre> <p>Stop node.</p> <p>Stopping the node will emit a <code>Disconnect-PeerConnection-Request</code> towards each currently connected peer, with disonnect cause \"REBOOTING\". The node will then wait until each peer has produced a <code>Disconnect-PeerConnection-Answer</code>, and regardless of the answer's result code or error status, the peer sockets are closed. Some diameter vendors may also already close the socket from their end immediately, if no messages are pending.</p> <p>After all connections have disconnected, the node's own listening sockets will close, and afterwards the active applications are shut down.</p> <p>Parameters:</p> Name Type Description Default <code>wait_timeout</code> <code>int</code> <p>Set a timeout for the DPR/DPA procedure to cpmplete. This should be usually fairly high, as time must be given for not only for the DPR/DPA messages to travel, but also for the peer connections to empty their in- and out buffers and for the applications to finish processing responses.</p> <code>180</code> <code>force</code> <code>bool</code> <p>Optionally skip DPR/DPA procedure and just force each peer connection to close immediately, with a very short (5-10 seconds) wait period for their threads to join.</p> <code>False</code>"},{"location":"api/peer/","title":"Peer","text":"<p>API reference for <code>diameter.node.peer</code>.</p>"},{"location":"api/peer/#diameter.node.peer.PEER_CLOSED","title":"PEER_CLOSED  <code>module-attribute</code>","text":"<pre><code>PEER_CLOSED = 28\n</code></pre> <p>PeerConnection has closed connection.</p>"},{"location":"api/peer/#diameter.node.peer.PEER_CLOSING","title":"PEER_CLOSING  <code>module-attribute</code>","text":"<pre><code>PEER_CLOSING = 27\n</code></pre> <p>PeerConnection is about to be closed; it will no longer read any messages and will close its socket as soon as the write buffer has been emptied. This state is  not part of rfc6733, it is only an internal temporary flag.</p>"},{"location":"api/peer/#diameter.node.peer.PEER_CONNECTED","title":"PEER_CONNECTED  <code>module-attribute</code>","text":"<pre><code>PEER_CONNECTED = 17\n</code></pre> <p>PeerConnection has established connection and is waiting for initial CER/CEA to  complete.</p>"},{"location":"api/peer/#diameter.node.peer.PEER_CONNECTING","title":"PEER_CONNECTING  <code>module-attribute</code>","text":"<pre><code>PEER_CONNECTING = 16\n</code></pre> <p>PeerConnection is in a state waiting for socket to become active.</p>"},{"location":"api/peer/#diameter.node.peer.PEER_DISCONNECTING","title":"PEER_DISCONNECTING  <code>module-attribute</code>","text":"<pre><code>PEER_DISCONNECTING = 26\n</code></pre> <p>PeerConnection has sent a disconnect-peer-request and is waiting for DPA.</p>"},{"location":"api/peer/#diameter.node.peer.PEER_READY","title":"PEER_READY  <code>module-attribute</code>","text":"<pre><code>PEER_READY = 18\n</code></pre> <p>PeerConnection is ready to process messages.</p>"},{"location":"api/peer/#diameter.node.peer.PEER_READY_WAITING_DWA","title":"PEER_READY_WAITING_DWA  <code>module-attribute</code>","text":"<pre><code>PEER_READY_WAITING_DWA = 19\n</code></pre> <p>PeerConnection is ready to process messages, but is waiting for a DWA.</p>"},{"location":"api/peer/#diameter.node.peer.PEER_RECV","title":"PEER_RECV  <code>module-attribute</code>","text":"<pre><code>PEER_RECV = 1\n</code></pre> <p>PeerConnection is a server, i.e. receives requests and sends answers.</p>"},{"location":"api/peer/#diameter.node.peer.PEER_SEND","title":"PEER_SEND  <code>module-attribute</code>","text":"<pre><code>PEER_SEND = 2\n</code></pre> <p>PeerConnection is a client, i.e. sends requests and receives answers.</p>"},{"location":"api/peer/#diameter.node.peer.PEER_TRANSPORT_SCTP","title":"PEER_TRANSPORT_SCTP  <code>module-attribute</code>","text":"<pre><code>PEER_TRANSPORT_SCTP = 11\n</code></pre> <p>PeerConnection connection is via SCTP.</p>"},{"location":"api/peer/#diameter.node.peer.PEER_TRANSPORT_TCP","title":"PEER_TRANSPORT_TCP  <code>module-attribute</code>","text":"<pre><code>PEER_TRANSPORT_TCP = 10\n</code></pre> <p>PeerConnection connection is via TCP.</p>"},{"location":"api/peer/#diameter.node.peer.Peer","title":"Peer  <code>dataclass</code>","text":"<p>Single configured or known peer.</p> <p>Collects all settings and a few timers for a single peer. The node collects one instance of <code>Peer</code> for every configured peer, or every discovered unknown peer. There exists one peer for each FQDN. An instance of <code>Peer</code> exists whether the peer is currently connected or not. The state peer connectivity is determined by the <code>connection</code> attribute.</p>"},{"location":"api/peer/#diameter.node.peer.Peer.cea_timeout","title":"cea_timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cea_timeout: int = None\n</code></pre> <p>Timeout waiting for a CEA after sending a CER. If no CEA is received  within this timeframe, the connection to the peer is closed.</p>"},{"location":"api/peer/#diameter.node.peer.Peer.cer_timeout","title":"cer_timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cer_timeout: int = None\n</code></pre> <p>Timeout waiting for a CER after receiving a connection attempt. If the  peer does not send a CER within this timeframe, the connection is closed.</p>"},{"location":"api/peer/#diameter.node.peer.Peer.connection","title":"connection  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>connection: PeerConnection = None\n</code></pre> <p>The actual, current connection to the peer. If the peer is not  connected, the value will be <code>None</code>. Note that even if the peer may be  connected, the actual connection readiness is determined by the  <code>Peer.connection.state</code>  attribute.</p>"},{"location":"api/peer/#diameter.node.peer.Peer.counters","title":"counters  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>counters: PeerCounters = dataclasses.field(default_factory=PeerCounters)\n</code></pre> <p>Peer statistics.</p>"},{"location":"api/peer/#diameter.node.peer.Peer.disconnected_since","title":"disconnected_since  <code>property</code>","text":"<pre><code>disconnected_since: int\n</code></pre> <p>Time since last disconnect, as seconds. If the peer has never been disconnected, the value -1 is returned.</p>"},{"location":"api/peer/#diameter.node.peer.Peer.dwa_timeout","title":"dwa_timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dwa_timeout: int = None\n</code></pre> <p>Timeout waiting for a DWA after sending a DWR. If no DWA is received  within this timeframe, the connection to the peer is closed.</p>"},{"location":"api/peer/#diameter.node.peer.Peer.idle_timeout","title":"idle_timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idle_timeout: int = None\n</code></pre> <p>Time spent idle before a DWR is triggered.</p>"},{"location":"api/peer/#diameter.node.peer.Peer.ip_addresses","title":"ip_addresses  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ip_addresses: list[str] = dataclasses.field(default_factory=list)\n</code></pre> <p>A list of IP addresses configured for the peer.</p>"},{"location":"api/peer/#diameter.node.peer.Peer.last_connect","title":"last_connect  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>last_connect: int = None\n</code></pre> <p>Unix timestamp of last successful connect.</p>"},{"location":"api/peer/#diameter.node.peer.Peer.last_disconnect","title":"last_disconnect  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>last_disconnect: int = None\n</code></pre> <p>Unix timestamp of last disconnect.</p>"},{"location":"api/peer/#diameter.node.peer.Peer.node_name","title":"node_name  <code>instance-attribute</code>","text":"<pre><code>node_name: str\n</code></pre> <p>Configured node name.</p>"},{"location":"api/peer/#diameter.node.peer.Peer.persistent","title":"persistent  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>persistent: bool = False\n</code></pre> <p>Indicates that the connection to the peer is automatically established, at Node startup and at connection lost (see <code>reconnect_wait</code> timer). A  connection is automatically established regardless of whether the node acts  as a server or a client.</p>"},{"location":"api/peer/#diameter.node.peer.Peer.port","title":"port  <code>instance-attribute</code>","text":"<pre><code>port: int\n</code></pre> <p>Port number is always set, even if the peer has not been configured  for outgoing connections. It defaults to 3868.</p>"},{"location":"api/peer/#diameter.node.peer.Peer.realm_name","title":"realm_name  <code>instance-attribute</code>","text":"<pre><code>realm_name: str\n</code></pre> <p>Configured realm name.</p>"},{"location":"api/peer/#diameter.node.peer.Peer.reconnect_wait","title":"reconnect_wait  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reconnect_wait: int = 30\n</code></pre> <p>Time waited before a reconnect is attempted for a persistent peer. The wait time is only applied in a scenario where the peer connection has failed least once and has the <code>persistent</code> attribute enabled. If the peer has not yet (ever) been disconnected, a connection attempt is made immediately.</p>"},{"location":"api/peer/#diameter.node.peer.Peer.transport","title":"transport  <code>instance-attribute</code>","text":"<pre><code>transport: int\n</code></pre> <p>Transport method, either <code>PEER_TRANSPORT_TCP</code> or  <code>PEER_TRANSPORT_SCTP</code>.</p>"},{"location":"api/peer/#diameter.node.peer.PeerConnection","title":"PeerConnection","text":"<pre><code>PeerConnection(peer_ip: list[str] | str, peer_port: int, peer_direction: int, interrupt_fileno: int)\n</code></pre> <p>A connection with another diameter node.</p> <p>Instances of this class are assigned as the value for the <code>Peer.connection</code> attribute. Connections are created and closed by the parent governing diameter node.</p> <p>Parameters:</p> Name Type Description Default <code>peer_ip</code> <code>list[str] | str</code> <p>Either a list of possible IP addresses to connect to, or an individual IP address that the connection socket is already connected with.</p> required <code>peer_port</code> <code>int</code> <p>Peer connection port number</p> required <code>peer_direction</code> <code>int</code> <p>Indicates whether the connection is either a receiving or a sending instance</p> required <code>interrupt_fileno</code> <code>int</code> <p>A write socket/pipe file number that this connection will write its connection ID every time it needs attention. This occurs most often when the connection has something to write and needs to wake up the parent node's <code>select</code> sleep.</p> required"},{"location":"api/peer/#diameter.node.peer.PeerConnection.acct_application_ids","title":"acct_application_ids  <code>instance-attribute</code>","text":"<pre><code>acct_application_ids: list[int] = []\n</code></pre> <p>List of supported accounting application IDs for this peer. The  list is populated when CER/CEA has been completed and will be used by  the node to route messages to their proper applications.</p>"},{"location":"api/peer/#diameter.node.peer.PeerConnection.auth_application_ids","title":"auth_application_ids  <code>instance-attribute</code>","text":"<pre><code>auth_application_ids: list[int] = []\n</code></pre> <p>List of supported authentication application IDs for this peer. The  list is populated when CER/CEA has been completed and will be used by  the node to route messages to their proper applications.</p>"},{"location":"api/peer/#diameter.node.peer.PeerConnection.dwa_wait_time","title":"dwa_wait_time  <code>property</code>","text":"<pre><code>dwa_wait_time: int\n</code></pre> <p>Time spent waiting for DWA, in seconds. If no DWR has been sent, returns zero.</p>"},{"location":"api/peer/#diameter.node.peer.PeerConnection.hop_by_hop_seq","title":"hop_by_hop_seq  <code>instance-attribute</code>","text":"<pre><code>hop_by_hop_seq = SequenceGenerator()\n</code></pre> <p>A sequence generator that will produce unique hop-by-hop IDs. Use  <code>PeerConnection.hop_by_hop_seq.next_sequence()</code> to retrieve the next  ID.</p>"},{"location":"api/peer/#diameter.node.peer.PeerConnection.host_identity","title":"host_identity  <code>instance-attribute</code>","text":"<pre><code>host_identity: str = ''\n</code></pre> <p>Resolved peer host ID. Will be set after CER/CEA has taken place.</p>"},{"location":"api/peer/#diameter.node.peer.PeerConnection.host_ip_address","title":"host_ip_address  <code>instance-attribute</code>","text":"<pre><code>host_ip_address: list[str] = []\n</code></pre> <p>Node's host IP addresses, resolved at the time of peer creation.</p>"},{"location":"api/peer/#diameter.node.peer.PeerConnection.ident","title":"ident  <code>instance-attribute</code>","text":"<pre><code>ident: str = '00' * 6\n</code></pre> <p>A unique (for the lifetime of the parent node) connection  identifier, a 6-byte long hexadecimal string.</p>"},{"location":"api/peer/#diameter.node.peer.PeerConnection.ip","title":"ip  <code>instance-attribute</code>","text":"<pre><code>ip: list[str] | str = peer_ip\n</code></pre> <p>The actual peer IP address(es) that the connection socket is  connected with.</p>"},{"location":"api/peer/#diameter.node.peer.PeerConnection.is_receiver","title":"is_receiver  <code>property</code>","text":"<pre><code>is_receiver: bool\n</code></pre> <p>Indicates the direction of connectivity. A receiver is a connection that has been established by a foreign peer, towards us. A receiver can both send and receive diameter messages, this property affects mostly only the CER/CEA procedure.</p>"},{"location":"api/peer/#diameter.node.peer.PeerConnection.is_sender","title":"is_sender  <code>property</code>","text":"<pre><code>is_sender: bool\n</code></pre> <p>Indicates the direction of connectivity. A sender is a connection that has been by our node, towards a foreign peer. A sender can both send and receive diameter messages, this property affects mostly only the CER/CEA procedure.</p>"},{"location":"api/peer/#diameter.node.peer.PeerConnection.is_waiting_for_dwa","title":"is_waiting_for_dwa  <code>property</code>","text":"<pre><code>is_waiting_for_dwa\n</code></pre> <p>Indicates that the connection is in a waiting-for-DWA state.</p>"},{"location":"api/peer/#diameter.node.peer.PeerConnection.last_read_since","title":"last_read_since  <code>property</code>","text":"<pre><code>last_read_since: int\n</code></pre> <p>Seconds since bytes were last receveid from the network.</p>"},{"location":"api/peer/#diameter.node.peer.PeerConnection.message_handler","title":"message_handler  <code>instance-attribute</code>","text":"<pre><code>message_handler: Callable[[PeerConnection, _AnyMessageType], None] = lambda , : None\n</code></pre> <p>A callback function that will be called each time a diameter  message is received. This should always be <code>Node._receive_message</code>.</p>"},{"location":"api/peer/#diameter.node.peer.PeerConnection.node_name","title":"node_name  <code>instance-attribute</code>","text":"<pre><code>node_name: str = ''\n</code></pre> <p>Configured node name. Is set for every known peer and should always  equal <code>host_identity</code>. If connections from unknown peers are accepted, this attribute remains always empty.</p>"},{"location":"api/peer/#diameter.node.peer.PeerConnection.origin_host","title":"origin_host  <code>instance-attribute</code>","text":"<pre><code>origin_host: str = ''\n</code></pre> <p>The value that will be used in sent requests, in the Host-Origin  AVP.</p>"},{"location":"api/peer/#diameter.node.peer.PeerConnection.port","title":"port  <code>instance-attribute</code>","text":"<pre><code>port: int = peer_port\n</code></pre> <p>The peer connection socket port.</p>"},{"location":"api/peer/#diameter.node.peer.PeerConnection.socket_fileno","title":"socket_fileno  <code>instance-attribute</code>","text":"<pre><code>socket_fileno: int = 0\n</code></pre> <p>The ID of the underlying socket. The peer does not hold the socket  itself, only the ID. The sockets are tracked by the parent node.</p>"},{"location":"api/peer/#diameter.node.peer.PeerConnection.socket_proto","title":"socket_proto  <code>instance-attribute</code>","text":"<pre><code>socket_proto: int = 0\n</code></pre> <p>Connected socket protocol, either PEER_TRANSPORT_TCP or  PEER_TRANSPORT_SCTP.</p>"},{"location":"api/peer/#diameter.node.peer.PeerConnection.state","title":"state  <code>instance-attribute</code>","text":"<pre><code>state: int = PEER_CLOSED\n</code></pre> <p>The current peer state, one of <code>PEER_*</code> constants. The peer will  go through a transition of CONNECTING - CONNECTED - READY and will not handle any messages until the READY state has been reached.</p>"},{"location":"api/peer/#diameter.node.peer.PeerConnection.add_in_bytes","title":"add_in_bytes","text":"<pre><code>add_in_bytes(read_bytes: bytes)\n</code></pre> <p>Add network-received bytes to parse and handle.</p> <p>Parameters:</p> Name Type Description Default <code>read_bytes</code> <code>bytes</code> <p>A byte string. Does not have to contain a complete message; the connection will buffer received bytes internally, until at least one valid message has been received</p> required"},{"location":"api/peer/#diameter.node.peer.PeerConnection.add_out_msg","title":"add_out_msg","text":"<pre><code>add_out_msg(out_msg: _AnyMessageType)\n</code></pre> <p>Add an outgoing Diameter message to send to network.</p> <p>Parameters:</p> Name Type Description Default <code>out_msg</code> <code>_AnyMessageType</code> <p>A message to send back towards the network. The message is queued internally and sent out as soon as possible. Messages are processed in the order that they were added.</p> required"},{"location":"api/peer/#diameter.node.peer.PeerConnection.close","title":"close","text":"<pre><code>close(signal_node: bool = True)\n</code></pre> <p>Close the peer connection.</p> <p>Sets peer connection state as closed and signals parent Node to close the underlying socket. Also stops processing input and output bytes immediately.</p> <p>Parameters:</p> Name Type Description Default <code>signal_node</code> <code>bool</code> <p>Send a signal to parent node so that it knows that the underlying socket should be closed. Should always be set to True, unless the socket has already been closed, before shutting down the peer.</p> <code>True</code>"},{"location":"api/peer/#diameter.node.peer.PeerConnection.demand_attention","title":"demand_attention","text":"<pre><code>demand_attention()\n</code></pre> <p>Signal parent node that data can be sent or read for this peer.</p>"},{"location":"api/peer/#diameter.node.peer.PeerConnection.remove_out_bytes","title":"remove_out_bytes","text":"<pre><code>remove_out_bytes(sent_bytes: int)\n</code></pre> <p>Remove a given amount of bytes from outgoing buffer.</p>"},{"location":"api/peer/#diameter.node.peer.PeerConnection.reset_last_dwa","title":"reset_last_dwa","text":"<pre><code>reset_last_dwa()\n</code></pre> <p>Mark that a DWA has been received.</p> <p>Resets the timer that starts counting from a sent DWR. If no DWA is received within the configured timeout period, the peer connection is closed.</p>"},{"location":"api/peer/#diameter.node.peer.PeerConnection.reset_last_dwr","title":"reset_last_dwr","text":"<pre><code>reset_last_dwr()\n</code></pre> <p>Mark that a DWR has been sent.</p> <p>Starts the DWA wait timer and changes connection state to PEER_READY_WAITING_DWA.</p>"},{"location":"api/peer/#diameter.node.peer.PeerConnection.reset_last_message","title":"reset_last_message","text":"<pre><code>reset_last_message()\n</code></pre> <p>Mark that a full diameter message has been received.</p> <p>Resets the internal idle counter.</p>"},{"location":"api/peer/#diameter.node.peer.PeerConnection.reset_last_read","title":"reset_last_read","text":"<pre><code>reset_last_read()\n</code></pre> <p>Mark that bytes have been received from the network.</p> <p>Resets the internal idle counter.</p>"},{"location":"api/peer/#diameter.node.peer.PeerCounters","title":"PeerCounters  <code>dataclass</code>","text":"<p>Peer message counters.</p>"},{"location":"api/utilities/","title":"Node utilities","text":"<p>API reference for various utilities in <code>diameter.node</code>.</p>"},{"location":"api/utilities/#diameter.node.SequenceGenerator","title":"SequenceGenerator","text":"<pre><code>SequenceGenerator(include_now: int = None)\n</code></pre> <p>A sequence generator base class.</p> <p>By default, is just a non-persistent counter that loops back to 1 when max sequence is reached. Can be overwritten by implementing parties, if any kind of persistence over reboots is required.</p> <p>Parameters:</p> Name Type Description Default <code>include_now</code> <code>int</code> <p>An optional unix timestamp. If provided, sets the high order bits of the initial sequence value to the provided time, as suggested by rfc6733. The remaining bits are always initialised to a random value.</p> <code>None</code>"},{"location":"api/utilities/#diameter.node.SequenceGenerator.sequence","title":"sequence  <code>property</code>","text":"<pre><code>sequence: int\n</code></pre> <p>Current sequence number.</p>"},{"location":"api/utilities/#diameter.node.SequenceGenerator.next_sequence","title":"next_sequence","text":"<pre><code>next_sequence() -&gt; int\n</code></pre> <p>Increase and then return current sequence.</p>"},{"location":"api/utilities/#diameter.node.SessionGenerator","title":"SessionGenerator","text":"<pre><code>SessionGenerator(node_name: str)\n</code></pre> <p>A sequential session generator that guarantees uniqueness.</p> <p>This generator produces diameter session IDs that conform to rfc6733 8.8 by producing \"globally and eternally unique\" IDs, by creating session IDs that begin with the diameter entity and have \";\"-separated sections of hexadecimal values that guarantee uniqueness. Optional implementation specific values may be appended to each session.</p> <p>The rfc-suggested method of producing uniqueness is not used. Instead, the generator sets a base initial value on generator creation that equals the current time. This value remains unchanged for the lifetime of the generator. The generator also creates a random 64-bit integer on startup and will increase it by one for every new session ID. The integer values are encoded in hexacecimal. The format is:</p> <pre><code>&lt;DiameterIdentity&gt;;&lt;startup timestamp&gt;;&lt;high 32 bits&gt;;&lt;low 32 bits&gt;[;&lt;optional values&gt;]\n</code></pre> <p>The generator holds a threading lock while session IDs are generated, ensuring that no duplicate IDs may be produced. If the internal 64-bit sequence reaches maximum value of 0xffffffffffffffff, it overflows back to 1.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; g = SessionGenerator(\"test2.gy.local.realm\")\n&gt;&gt;&gt; g.next_id()\ntest2.gy.local.realm;6571a525;5bd295f2;6c76d6b6\n&gt;&gt;&gt; g.next_id()\ntest2.gy.local.realm;6571a525;5bd295f2;6c76d6b7\n&gt;&gt;&gt; # note how the base timestamp changes when generator restarts:\ng = SessionGenerator(\"test2.gy.local.realm\")\n&gt;&gt;&gt; g.next_id()\ntest2.gy.local.realm;6571a525;1967cbd0;8e9e3a16\n&gt;&gt;&gt; # passing optional values:\n&gt;&gt;&gt; g.next_id(\"user@host\", \"hello\")\ntest2.gy.local.realm;6571a525;1967cbd0;8e9e3a17;user@host;hello\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>node_name</code> <code>str</code> <p>Diameter identity of the node, will be embedded in the generated session IDs.</p> required"},{"location":"api/utilities/#diameter.node.SessionGenerator.next_id","title":"next_id","text":"<pre><code>next_id(*optional: str) -&gt; str\n</code></pre> <p>Generate the next session ID.</p> <p>Parameters:</p> Name Type Description Default <code>*optional</code> <code>str</code> <p>Any string values to append as optional fields at the end of the generated session IDs. The values will be separated by \";\"</p> <code>()</code>"},{"location":"api/utilities/#diameter.node.parse_diameter_uri","title":"parse_diameter_uri","text":"<pre><code>parse_diameter_uri(uri: str) -&gt; DiameterUri\n</code></pre> <p>Parses a diameter URI.</p> <p>Follows the rfc6733 4.3.1 specification for a DiameterURI value and parses URIs such as:</p> <ul> <li>aaa://host.example.com;transport=tcp</li> <li>aaa://host.example.com:5959;transport=tcp;protocol=diameter</li> <li>aaas://host.example.com;transport=sctp</li> </ul> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>A string that contains at least \"://\"</p> required <p>Returns:</p> Type Description <code>DiameterUri</code> <p>A <code>DiameterUri</code> named tuple instance, which contains the scheme, fqdn port, params and is_secure attributes</p>"},{"location":"api/utilities/#diameter.node._helpers.DiameterUri","title":"DiameterUri","text":"<p>             Bases: <code>NamedTuple</code></p>"},{"location":"api/utilities/#diameter.node._helpers.DiameterUri.fqdn","title":"fqdn  <code>instance-attribute</code>","text":"<pre><code>fqdn: str\n</code></pre>"},{"location":"api/utilities/#diameter.node._helpers.DiameterUri.is_secure","title":"is_secure  <code>instance-attribute</code>","text":"<pre><code>is_secure: bool\n</code></pre>"},{"location":"api/utilities/#diameter.node._helpers.DiameterUri.params","title":"params  <code>instance-attribute</code>","text":"<pre><code>params: dict\n</code></pre>"},{"location":"api/utilities/#diameter.node._helpers.DiameterUri.port","title":"port  <code>instance-attribute</code>","text":"<pre><code>port: int\n</code></pre>"},{"location":"api/utilities/#diameter.node._helpers.DiameterUri.scheme","title":"scheme  <code>instance-attribute</code>","text":"<pre><code>scheme: str\n</code></pre>"},{"location":"api/utilities/#diameter.node.validate_message_avps","title":"validate_message_avps","text":"<pre><code>validate_message_avps(msg: _AnyMessageType) -&gt; list[Avp]\n</code></pre> <p>Validate that a message has all the mandatory AVPs set.</p> <p>The validation works only for the commands that have a python implementation, containing an <code>avp_def</code> attribute, listing the mandatory AVPs. This is true for every <code>message.commands.*</code> subclass. For any other message type will return an empty list.</p> <p>Returns:</p> Type Description <code>list[Avp]</code> <p>A list of <code>Avp</code> instances with the AVP code and vendor ID set, for every AVP that is missing in the message</p>"},{"location":"api/commands/abort_session/","title":"Abort Session","text":"<p>API reference for <code>diameter.message.commands.abort_session</code>.</p> <p>This module contains Abort Session Request and Answer messages, implementing AVPs documented in <code>rfc6733</code>.</p>"},{"location":"api/commands/abort_session/#diameter.message.commands.abort_session.AbortSession","title":"AbortSession","text":"<pre><code>AbortSession(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>DefinedMessage</code></p> <p>An Abort-Session base message.</p> <p>This message class lists message attributes based on the current rfc6733 as python properties, acessible as instance attributes. AVPs not listed in the base protocol can be retrieved using the AbortSession.find_avps search method.</p> <p>Examples:</p> <p>AVPs accessible either as instance attributes or by searching:</p> <pre><code>&gt;&gt;&gt; msg = Message.from_bytes(b\"...\")\n&gt;&gt;&gt; msg.session_id\ndra1.mvno.net;2323;546\n&gt;&gt;&gt; msg.find_avps((AVP_SESSION_ID, 0))\n['dra1.mvno.net;2323;546']\n</code></pre> <p>When diameter message is decoded using Message.from_bytes, it returns either an instance of <code>AbortSessionRequest</code> or <code>AbortSessionAnswer</code> automatically:</p> <pre><code>&gt;&gt;&gt; msg = Message.from_bytes(b\"...\")\n&gt;&gt;&gt; assert msg.header.is_request is True\n&gt;&gt;&gt; assert isinstance(msg, AbortSessionRequest)\n</code></pre> <p>When creating a new message, the <code>AbortSessionRequest</code> or <code>AbortSessionAnswer</code> class should be instantiated directly, and values for AVPs set as class attributes:</p> <pre><code>&gt;&gt;&gt; msg = AbortSessionRequest()\n&gt;&gt;&gt; msg.session_id = \"dra1.mvno.net;2323;546\"\n</code></pre> <p>Other, custom AVPs can be appended to the message using the AbortSession.append_avp method, or by overwriting the <code>avp</code> attribute entirely. Regardless of the custom AVPs set, the mandatory values listed in RFC6733 must be set, however they can be set as <code>None</code>, if they are not to be used.</p> <p>Warning</p> <p>Every AVP documented for the subclasses of this command can be accessed as an instance attribute, even if the original network-received message did not contain that specific AVP. Such AVPs will be returned with the value <code>None</code> when accessed.</p> <p>Every other AVP not mentioned here, and not present in a network-received message will raise an <code>AttributeError</code> when being accessed; their presence should be validated with <code>hasattr</code> before accessing.</p>"},{"location":"api/commands/abort_session/#diameter.message.commands.abort_session.AbortSessionAnswer","title":"AbortSessionAnswer","text":"<pre><code>AbortSessionAnswer(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>AbortSession</code></p> <p>An Abort-Session-Answer message.</p>"},{"location":"api/commands/abort_session/#diameter.message.commands.abort_session.AbortSessionAnswer.error_message","title":"error_message  <code>instance-attribute</code>","text":"<pre><code>error_message: str\n</code></pre>"},{"location":"api/commands/abort_session/#diameter.message.commands.abort_session.AbortSessionAnswer.error_reporting_host","title":"error_reporting_host  <code>instance-attribute</code>","text":"<pre><code>error_reporting_host: bytes\n</code></pre>"},{"location":"api/commands/abort_session/#diameter.message.commands.abort_session.AbortSessionAnswer.failed_avp","title":"failed_avp  <code>instance-attribute</code>","text":"<pre><code>failed_avp: FailedAvp\n</code></pre>"},{"location":"api/commands/abort_session/#diameter.message.commands.abort_session.AbortSessionAnswer.origin_host","title":"origin_host  <code>instance-attribute</code>","text":"<pre><code>origin_host: bytes\n</code></pre>"},{"location":"api/commands/abort_session/#diameter.message.commands.abort_session.AbortSessionAnswer.origin_realm","title":"origin_realm  <code>instance-attribute</code>","text":"<pre><code>origin_realm: bytes\n</code></pre>"},{"location":"api/commands/abort_session/#diameter.message.commands.abort_session.AbortSessionAnswer.origin_state_id","title":"origin_state_id  <code>instance-attribute</code>","text":"<pre><code>origin_state_id: int\n</code></pre>"},{"location":"api/commands/abort_session/#diameter.message.commands.abort_session.AbortSessionAnswer.proxy_info","title":"proxy_info  <code>instance-attribute</code>","text":"<pre><code>proxy_info: list[ProxyInfo]\n</code></pre>"},{"location":"api/commands/abort_session/#diameter.message.commands.abort_session.AbortSessionAnswer.redirect_host","title":"redirect_host  <code>instance-attribute</code>","text":"<pre><code>redirect_host: list[str]\n</code></pre>"},{"location":"api/commands/abort_session/#diameter.message.commands.abort_session.AbortSessionAnswer.redirect_host_usage","title":"redirect_host_usage  <code>instance-attribute</code>","text":"<pre><code>redirect_host_usage: int\n</code></pre>"},{"location":"api/commands/abort_session/#diameter.message.commands.abort_session.AbortSessionAnswer.redirect_max_cache_time","title":"redirect_max_cache_time  <code>instance-attribute</code>","text":"<pre><code>redirect_max_cache_time: int\n</code></pre>"},{"location":"api/commands/abort_session/#diameter.message.commands.abort_session.AbortSessionAnswer.result_code","title":"result_code  <code>instance-attribute</code>","text":"<pre><code>result_code: int\n</code></pre>"},{"location":"api/commands/abort_session/#diameter.message.commands.abort_session.AbortSessionAnswer.route_record","title":"route_record  <code>instance-attribute</code>","text":"<pre><code>route_record: list[bytes]\n</code></pre>"},{"location":"api/commands/abort_session/#diameter.message.commands.abort_session.AbortSessionAnswer.session_id","title":"session_id  <code>instance-attribute</code>","text":"<pre><code>session_id: str\n</code></pre>"},{"location":"api/commands/abort_session/#diameter.message.commands.abort_session.AbortSessionAnswer.user_name","title":"user_name  <code>instance-attribute</code>","text":"<pre><code>user_name: str\n</code></pre>"},{"location":"api/commands/abort_session/#diameter.message.commands.abort_session.AbortSessionRequest","title":"AbortSessionRequest","text":"<pre><code>AbortSessionRequest(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>AbortSession</code></p> <p>An Abort-Session-Request message.</p>"},{"location":"api/commands/abort_session/#diameter.message.commands.abort_session.AbortSessionRequest.auth_application_id","title":"auth_application_id  <code>instance-attribute</code>","text":"<pre><code>auth_application_id: int\n</code></pre>"},{"location":"api/commands/abort_session/#diameter.message.commands.abort_session.AbortSessionRequest.destination_host","title":"destination_host  <code>instance-attribute</code>","text":"<pre><code>destination_host: bytes\n</code></pre>"},{"location":"api/commands/abort_session/#diameter.message.commands.abort_session.AbortSessionRequest.destination_realm","title":"destination_realm  <code>instance-attribute</code>","text":"<pre><code>destination_realm: bytes\n</code></pre>"},{"location":"api/commands/abort_session/#diameter.message.commands.abort_session.AbortSessionRequest.origin_host","title":"origin_host  <code>instance-attribute</code>","text":"<pre><code>origin_host: bytes\n</code></pre>"},{"location":"api/commands/abort_session/#diameter.message.commands.abort_session.AbortSessionRequest.origin_realm","title":"origin_realm  <code>instance-attribute</code>","text":"<pre><code>origin_realm: bytes\n</code></pre>"},{"location":"api/commands/abort_session/#diameter.message.commands.abort_session.AbortSessionRequest.origin_state_id","title":"origin_state_id  <code>instance-attribute</code>","text":"<pre><code>origin_state_id: int\n</code></pre>"},{"location":"api/commands/abort_session/#diameter.message.commands.abort_session.AbortSessionRequest.proxy_info","title":"proxy_info  <code>instance-attribute</code>","text":"<pre><code>proxy_info: list[ProxyInfo]\n</code></pre>"},{"location":"api/commands/abort_session/#diameter.message.commands.abort_session.AbortSessionRequest.route_record","title":"route_record  <code>instance-attribute</code>","text":"<pre><code>route_record: list[bytes]\n</code></pre>"},{"location":"api/commands/abort_session/#diameter.message.commands.abort_session.AbortSessionRequest.session_id","title":"session_id  <code>instance-attribute</code>","text":"<pre><code>session_id: str\n</code></pre>"},{"location":"api/commands/abort_session/#diameter.message.commands.abort_session.AbortSessionRequest.user_name","title":"user_name  <code>instance-attribute</code>","text":"<pre><code>user_name: str\n</code></pre>"},{"location":"api/commands/abort_session/#diameter.message.commands.abort_session.FailedAvp","title":"FailedAvp  <code>dataclass</code>","text":"<p>A data container that represents the \"Failed-AVP\" grouped AVP.</p> <p><code>rfc6733</code>, defines this as just a list of arbitrary AVPs; the actual failed AVPs should be copied into the <code>additional_avps</code> attribute.</p>"},{"location":"api/commands/abort_session/#diameter.message.commands.abort_session.FailedAvp.additional_avps","title":"additional_avps  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>additional_avps: list[Avp] = dataclasses.field(default_factory=list)\n</code></pre>"},{"location":"api/commands/abort_session/#diameter.message.commands.abort_session.ProxyInfo","title":"ProxyInfo  <code>dataclass</code>","text":"<p>A data container that represents the \"Proxy-Info\" grouped AVP.</p>"},{"location":"api/commands/abort_session/#diameter.message.commands.abort_session.ProxyInfo.proxy_host","title":"proxy_host  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>proxy_host: bytes = None\n</code></pre>"},{"location":"api/commands/abort_session/#diameter.message.commands.abort_session.ProxyInfo.proxy_state","title":"proxy_state  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>proxy_state: bytes = None\n</code></pre>"},{"location":"api/commands/accounting/","title":"Accounting","text":"<p>API reference for <code>diameter.message.commands.accounting</code>.</p> <p>This module contains Accounting Request and Answer messages, implementing AVPs documented in rfc6733.</p>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.Accounting","title":"Accounting","text":"<pre><code>Accounting(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>DefinedMessage</code></p> <p>An Accounting message.</p> <p>This message class lists message attributes based on the current RFC6733 as python properties, acessible as instance attributes. AVPs not listed in the base protocol can be retrieved using the Accounting.find_avps search method.</p> <p>Examples:</p> <p>AVPs accessible either as instance attributes or by searching:</p> <pre><code>&gt;&gt;&gt; msg = Message.from_bytes(b\"...\")\n&gt;&gt;&gt; msg.session_id\ndra1.mvno.net;2323;546\n&gt;&gt;&gt; msg.find_avps((AVP_SESSION_ID, 0))\n['dra1.mvno.net;2323;546']\n</code></pre> <p>When diameter message is decoded using Message.from_bytes, it returns either an instance of <code>AccountingRequest</code> or <code>AccountingAnswer</code> automatically:</p> <pre><code>&gt;&gt;&gt; msg = Message.from_bytes(b\"...\")\n&gt;&gt;&gt; assert msg.header.is_request is True\n&gt;&gt;&gt; assert isinstance(msg, AccountingRequest)\n</code></pre> <p>When creating a new message, the <code>AccountingRequest</code> or <code>AccountingAnswer</code> class should be instantiated directly, and values for AVPs set as class attributes:</p> <pre><code>&gt;&gt;&gt; msg = AccountingRequest()\n&gt;&gt;&gt; msg.session_id = \"dra1.mvno.net;2323;546\"\n</code></pre> <p>Other, custom AVPs can be appended to the message using the Accounting.append_avp method, or by overwriting the <code>avp</code> attribute entirely. Regardless of the custom AVPs set, the mandatory values listed in RFC6733 must be set, however they can be set as <code>None</code>, if they are not to be used.</p> <p>Warning</p> <p>Every AVP documented for the subclasses of this command can be accessed as an instance attribute, even if the original network-received message did not contain that specific AVP. Such AVPs will be returned with the value <code>None</code> when accessed.</p> <p>Every other AVP not mentioned here, and not present in a network-received message will raise an <code>AttributeError</code> when being accessed; their presence should be validated with <code>hasattr</code> before accessing.</p>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingAnswer","title":"AccountingAnswer","text":"<pre><code>AccountingAnswer(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>Accounting</code></p> <p>An Accounting-Answer message.</p>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingAnswer.accounting_realtime_required","title":"accounting_realtime_required  <code>instance-attribute</code>","text":"<pre><code>accounting_realtime_required: int\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingAnswer.accounting_record_number","title":"accounting_record_number  <code>instance-attribute</code>","text":"<pre><code>accounting_record_number: int\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingAnswer.accounting_record_type","title":"accounting_record_type  <code>instance-attribute</code>","text":"<pre><code>accounting_record_type: int\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingAnswer.accounting_sub_session_id","title":"accounting_sub_session_id  <code>instance-attribute</code>","text":"<pre><code>accounting_sub_session_id: int\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingAnswer.acct_application_id","title":"acct_application_id  <code>instance-attribute</code>","text":"<pre><code>acct_application_id: int\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingAnswer.acct_interim_interval","title":"acct_interim_interval  <code>instance-attribute</code>","text":"<pre><code>acct_interim_interval: int\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingAnswer.acct_multi_session_id","title":"acct_multi_session_id  <code>instance-attribute</code>","text":"<pre><code>acct_multi_session_id: str\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingAnswer.acct_session_id","title":"acct_session_id  <code>instance-attribute</code>","text":"<pre><code>acct_session_id: bytes\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingAnswer.error_message","title":"error_message  <code>instance-attribute</code>","text":"<pre><code>error_message: str\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingAnswer.error_reporting_host","title":"error_reporting_host  <code>instance-attribute</code>","text":"<pre><code>error_reporting_host: bytes\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingAnswer.event_timestamp","title":"event_timestamp  <code>instance-attribute</code>","text":"<pre><code>event_timestamp: datetime.datetime\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingAnswer.failed_avp","title":"failed_avp  <code>instance-attribute</code>","text":"<pre><code>failed_avp: FailedAvp\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingAnswer.origin_host","title":"origin_host  <code>instance-attribute</code>","text":"<pre><code>origin_host: bytes\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingAnswer.origin_realm","title":"origin_realm  <code>instance-attribute</code>","text":"<pre><code>origin_realm: bytes\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingAnswer.origin_state_id","title":"origin_state_id  <code>instance-attribute</code>","text":"<pre><code>origin_state_id: int\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingAnswer.proxy_info","title":"proxy_info  <code>instance-attribute</code>","text":"<pre><code>proxy_info: list[ProxyInfo]\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingAnswer.result_code","title":"result_code  <code>instance-attribute</code>","text":"<pre><code>result_code: int\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingAnswer.session_id","title":"session_id  <code>instance-attribute</code>","text":"<pre><code>session_id: str\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingAnswer.user_name","title":"user_name  <code>instance-attribute</code>","text":"<pre><code>user_name: str\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingAnswer.vendor_specific_application_id","title":"vendor_specific_application_id  <code>instance-attribute</code>","text":"<pre><code>vendor_specific_application_id: VendorSpecificApplicationId\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingRequest","title":"AccountingRequest","text":"<pre><code>AccountingRequest(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>Accounting</code></p> <p>An Accounting-Request message.</p>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingRequest.accounting_realtime_required","title":"accounting_realtime_required  <code>instance-attribute</code>","text":"<pre><code>accounting_realtime_required: int\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingRequest.accounting_record_number","title":"accounting_record_number  <code>instance-attribute</code>","text":"<pre><code>accounting_record_number: int\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingRequest.accounting_record_type","title":"accounting_record_type  <code>instance-attribute</code>","text":"<pre><code>accounting_record_type: int\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingRequest.accounting_sub_session_id","title":"accounting_sub_session_id  <code>instance-attribute</code>","text":"<pre><code>accounting_sub_session_id: int\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingRequest.acct_application_id","title":"acct_application_id  <code>instance-attribute</code>","text":"<pre><code>acct_application_id: int\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingRequest.acct_interim_interval","title":"acct_interim_interval  <code>instance-attribute</code>","text":"<pre><code>acct_interim_interval: int\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingRequest.acct_multi_session_id","title":"acct_multi_session_id  <code>instance-attribute</code>","text":"<pre><code>acct_multi_session_id: str\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingRequest.acct_session_id","title":"acct_session_id  <code>instance-attribute</code>","text":"<pre><code>acct_session_id: bytes\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingRequest.destination_host","title":"destination_host  <code>instance-attribute</code>","text":"<pre><code>destination_host: bytes\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingRequest.destination_realm","title":"destination_realm  <code>instance-attribute</code>","text":"<pre><code>destination_realm: bytes\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingRequest.event_timestamp","title":"event_timestamp  <code>instance-attribute</code>","text":"<pre><code>event_timestamp: datetime.datetime\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingRequest.origin_host","title":"origin_host  <code>instance-attribute</code>","text":"<pre><code>origin_host: bytes\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingRequest.origin_realm","title":"origin_realm  <code>instance-attribute</code>","text":"<pre><code>origin_realm: bytes\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingRequest.origin_state_id","title":"origin_state_id  <code>instance-attribute</code>","text":"<pre><code>origin_state_id: int\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingRequest.proxy_info","title":"proxy_info  <code>instance-attribute</code>","text":"<pre><code>proxy_info: list[ProxyInfo]\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingRequest.route_record","title":"route_record  <code>instance-attribute</code>","text":"<pre><code>route_record: list[bytes]\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingRequest.session_id","title":"session_id  <code>instance-attribute</code>","text":"<pre><code>session_id: str\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingRequest.user_name","title":"user_name  <code>instance-attribute</code>","text":"<pre><code>user_name: str\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.AccountingRequest.vendor_specific_application_id","title":"vendor_specific_application_id  <code>instance-attribute</code>","text":"<pre><code>vendor_specific_application_id: VendorSpecificApplicationId\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.ProxyInfo","title":"ProxyInfo  <code>dataclass</code>","text":"<p>A data container that represents the \"Proxy-Info\" grouped AVP.</p>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.ProxyInfo.proxy_host","title":"proxy_host  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>proxy_host: bytes = None\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.ProxyInfo.proxy_state","title":"proxy_state  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>proxy_state: bytes = None\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.VendorSpecificApplicationId","title":"VendorSpecificApplicationId  <code>dataclass</code>","text":"<p>A data container that represents the \"Vendor-Specific-Application-ID\" grouped AVP.</p>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.VendorSpecificApplicationId.acct_application_id","title":"acct_application_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>acct_application_id: int = None\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.VendorSpecificApplicationId.auth_application_id","title":"auth_application_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>auth_application_id: int = None\n</code></pre>"},{"location":"api/commands/accounting/#diameter.message.commands.accounting.VendorSpecificApplicationId.vendor_id","title":"vendor_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>vendor_id: int = None\n</code></pre>"},{"location":"api/commands/capabilities_exchange/","title":"Capabilities Exchange","text":"<p>API reference for <code>diameter.message.commands.capabilities_exchange</code>.</p> <p>This module contains Capabilities-Exchange Request and Answer messages,  implementing AVPs documented in rfc6733.</p>"},{"location":"api/commands/capabilities_exchange/#diameter.message.commands.capabilities_exchange.CapabilitiesExchange","title":"CapabilitiesExchange","text":"<pre><code>CapabilitiesExchange(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>DefinedMessage</code></p> <p>A Capabilities-Exchange message.</p> <p>This message class lists message attributes based on the current RFC6733 as python properties, acessible as instance attributes. AVPs not listed in the base protocol can be retrieved using the CapabilitiesExchange.find_avps search method.</p> <p>Examples:</p> <p>AVPs accessible either as instance attributes or by searching:</p> <pre><code>&gt;&gt;&gt; msg = Message.from_bytes(b\"...\")\n&gt;&gt;&gt; msg.origin_realm\nb'mvno.net'\n&gt;&gt;&gt; msg.find_avps((AVP_ORIGIN_REALM, 0))\n[b'mvno.net']\n</code></pre> <p>When diameter message is decoded using Message.from_bytes, it returns either an instance of <code>CapabilitiesExchangeRequest</code> or <code>CapabilitiesExchangeAnswer</code> automatically:</p> <pre><code>&gt;&gt;&gt; msg = Message.from_bytes(b\"...\")\n&gt;&gt;&gt; assert msg.header.is_request is True\n&gt;&gt;&gt; assert isinstance(msg, CapabilitiesExchangeRequest)\n</code></pre> <p>When creating a new message, the <code>CapabilitiesExchangeRequest</code> or <code>CapabilitiesExchangeAnswer</code> class should be instantiated directly, and values for AVPs set as class attributes:</p> <pre><code>&gt;&gt;&gt; msg = CapabilitiesExchangeRequest()\n&gt;&gt;&gt; msg.origin_realm = b\"mvno.net\"\n</code></pre> <p>Other, custom AVPs can be appended to the message using the CapabilitiesExchange.append_avp method, or by overwriting the <code>avp</code> attribute entirely. Regardless of the custom AVPs set, the mandatory values listed in RFC6733 must be set, however they can be set as <code>None</code>, if they are not to be used.</p> <p>Warning</p> <p>Every AVP documented for the subclasses of this command can be accessed as an instance attribute, even if the original network-received message did not contain that specific AVP. Such AVPs will be returned with the value <code>None</code> when accessed.</p> <p>Every other AVP not mentioned here, and not present in a network-received message will raise an <code>AttributeError</code> when being accessed; their presence should be validated with <code>hasattr</code> before accessing.</p>"},{"location":"api/commands/capabilities_exchange/#diameter.message.commands.capabilities_exchange.CapabilitiesExchangeAnswer","title":"CapabilitiesExchangeAnswer","text":"<pre><code>CapabilitiesExchangeAnswer(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>CapabilitiesExchange</code></p> <p>A Capabilities-Exchange-Answer message.</p>"},{"location":"api/commands/capabilities_exchange/#diameter.message.commands.capabilities_exchange.CapabilitiesExchangeAnswer.acct_application_id","title":"acct_application_id  <code>instance-attribute</code>","text":"<pre><code>acct_application_id: list[int]\n</code></pre>"},{"location":"api/commands/capabilities_exchange/#diameter.message.commands.capabilities_exchange.CapabilitiesExchangeAnswer.auth_application_id","title":"auth_application_id  <code>instance-attribute</code>","text":"<pre><code>auth_application_id: list[int]\n</code></pre>"},{"location":"api/commands/capabilities_exchange/#diameter.message.commands.capabilities_exchange.CapabilitiesExchangeAnswer.error_message","title":"error_message  <code>instance-attribute</code>","text":"<pre><code>error_message: str\n</code></pre>"},{"location":"api/commands/capabilities_exchange/#diameter.message.commands.capabilities_exchange.CapabilitiesExchangeAnswer.failed_avp","title":"failed_avp  <code>instance-attribute</code>","text":"<pre><code>failed_avp: FailedAvp\n</code></pre>"},{"location":"api/commands/capabilities_exchange/#diameter.message.commands.capabilities_exchange.CapabilitiesExchangeAnswer.firmware_revision","title":"firmware_revision  <code>instance-attribute</code>","text":"<pre><code>firmware_revision: int\n</code></pre>"},{"location":"api/commands/capabilities_exchange/#diameter.message.commands.capabilities_exchange.CapabilitiesExchangeAnswer.host_ip_address","title":"host_ip_address  <code>instance-attribute</code>","text":"<pre><code>host_ip_address: list[str]\n</code></pre>"},{"location":"api/commands/capabilities_exchange/#diameter.message.commands.capabilities_exchange.CapabilitiesExchangeAnswer.inband_security_id","title":"inband_security_id  <code>instance-attribute</code>","text":"<pre><code>inband_security_id: list[int]\n</code></pre>"},{"location":"api/commands/capabilities_exchange/#diameter.message.commands.capabilities_exchange.CapabilitiesExchangeAnswer.origin_host","title":"origin_host  <code>instance-attribute</code>","text":"<pre><code>origin_host: bytes\n</code></pre>"},{"location":"api/commands/capabilities_exchange/#diameter.message.commands.capabilities_exchange.CapabilitiesExchangeAnswer.origin_realm","title":"origin_realm  <code>instance-attribute</code>","text":"<pre><code>origin_realm: bytes\n</code></pre>"},{"location":"api/commands/capabilities_exchange/#diameter.message.commands.capabilities_exchange.CapabilitiesExchangeAnswer.origin_state_id","title":"origin_state_id  <code>instance-attribute</code>","text":"<pre><code>origin_state_id: int\n</code></pre>"},{"location":"api/commands/capabilities_exchange/#diameter.message.commands.capabilities_exchange.CapabilitiesExchangeAnswer.product_name","title":"product_name  <code>instance-attribute</code>","text":"<pre><code>product_name: str\n</code></pre>"},{"location":"api/commands/capabilities_exchange/#diameter.message.commands.capabilities_exchange.CapabilitiesExchangeAnswer.result_code","title":"result_code  <code>instance-attribute</code>","text":"<pre><code>result_code: int\n</code></pre>"},{"location":"api/commands/capabilities_exchange/#diameter.message.commands.capabilities_exchange.CapabilitiesExchangeAnswer.supported_vendor_id","title":"supported_vendor_id  <code>instance-attribute</code>","text":"<pre><code>supported_vendor_id: list[int]\n</code></pre>"},{"location":"api/commands/capabilities_exchange/#diameter.message.commands.capabilities_exchange.CapabilitiesExchangeAnswer.vendor_id","title":"vendor_id  <code>instance-attribute</code>","text":"<pre><code>vendor_id: int\n</code></pre>"},{"location":"api/commands/capabilities_exchange/#diameter.message.commands.capabilities_exchange.CapabilitiesExchangeAnswer.vendor_specific_application_id","title":"vendor_specific_application_id  <code>instance-attribute</code>","text":"<pre><code>vendor_specific_application_id: list[VendorSpecificApplicationId]\n</code></pre>"},{"location":"api/commands/capabilities_exchange/#diameter.message.commands.capabilities_exchange.CapabilitiesExchangeRequest","title":"CapabilitiesExchangeRequest","text":"<pre><code>CapabilitiesExchangeRequest(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>CapabilitiesExchange</code></p> <p>A Capabilities-Exchange-Request message.</p>"},{"location":"api/commands/capabilities_exchange/#diameter.message.commands.capabilities_exchange.CapabilitiesExchangeRequest.acct_application_id","title":"acct_application_id  <code>instance-attribute</code>","text":"<pre><code>acct_application_id: list[int]\n</code></pre>"},{"location":"api/commands/capabilities_exchange/#diameter.message.commands.capabilities_exchange.CapabilitiesExchangeRequest.auth_application_id","title":"auth_application_id  <code>instance-attribute</code>","text":"<pre><code>auth_application_id: list[int]\n</code></pre>"},{"location":"api/commands/capabilities_exchange/#diameter.message.commands.capabilities_exchange.CapabilitiesExchangeRequest.firmware_revision","title":"firmware_revision  <code>instance-attribute</code>","text":"<pre><code>firmware_revision: int\n</code></pre>"},{"location":"api/commands/capabilities_exchange/#diameter.message.commands.capabilities_exchange.CapabilitiesExchangeRequest.host_ip_address","title":"host_ip_address  <code>instance-attribute</code>","text":"<pre><code>host_ip_address: list[str]\n</code></pre>"},{"location":"api/commands/capabilities_exchange/#diameter.message.commands.capabilities_exchange.CapabilitiesExchangeRequest.inband_security_id","title":"inband_security_id  <code>instance-attribute</code>","text":"<pre><code>inband_security_id: list[int]\n</code></pre>"},{"location":"api/commands/capabilities_exchange/#diameter.message.commands.capabilities_exchange.CapabilitiesExchangeRequest.origin_host","title":"origin_host  <code>instance-attribute</code>","text":"<pre><code>origin_host: bytes\n</code></pre>"},{"location":"api/commands/capabilities_exchange/#diameter.message.commands.capabilities_exchange.CapabilitiesExchangeRequest.origin_realm","title":"origin_realm  <code>instance-attribute</code>","text":"<pre><code>origin_realm: bytes\n</code></pre>"},{"location":"api/commands/capabilities_exchange/#diameter.message.commands.capabilities_exchange.CapabilitiesExchangeRequest.origin_state_id","title":"origin_state_id  <code>instance-attribute</code>","text":"<pre><code>origin_state_id: int\n</code></pre>"},{"location":"api/commands/capabilities_exchange/#diameter.message.commands.capabilities_exchange.CapabilitiesExchangeRequest.product_name","title":"product_name  <code>instance-attribute</code>","text":"<pre><code>product_name: str\n</code></pre>"},{"location":"api/commands/capabilities_exchange/#diameter.message.commands.capabilities_exchange.CapabilitiesExchangeRequest.supported_vendor_id","title":"supported_vendor_id  <code>instance-attribute</code>","text":"<pre><code>supported_vendor_id: list[int]\n</code></pre>"},{"location":"api/commands/capabilities_exchange/#diameter.message.commands.capabilities_exchange.CapabilitiesExchangeRequest.vendor_id","title":"vendor_id  <code>instance-attribute</code>","text":"<pre><code>vendor_id: int\n</code></pre>"},{"location":"api/commands/capabilities_exchange/#diameter.message.commands.capabilities_exchange.CapabilitiesExchangeRequest.vendor_specific_application_id","title":"vendor_specific_application_id  <code>instance-attribute</code>","text":"<pre><code>vendor_specific_application_id: list[VendorSpecificApplicationId]\n</code></pre>"},{"location":"api/commands/capabilities_exchange/#diameter.message.commands.capabilities_exchange.FailedAvp","title":"FailedAvp  <code>dataclass</code>","text":"<p>A data container that represents the \"Failed-AVP\" grouped AVP.</p> <p><code>rfc6733</code>, defines this as just a list of arbitrary AVPs; the actual failed AVPs should be copied into the <code>additional_avps</code> attribute.</p>"},{"location":"api/commands/capabilities_exchange/#diameter.message.commands.capabilities_exchange.FailedAvp.additional_avps","title":"additional_avps  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>additional_avps: list[Avp] = dataclasses.field(default_factory=list)\n</code></pre>"},{"location":"api/commands/capabilities_exchange/#diameter.message.commands.capabilities_exchange.VendorSpecificApplicationId","title":"VendorSpecificApplicationId  <code>dataclass</code>","text":"<p>A data container that represents the \"Vendor-Specific-Application-ID\" grouped AVP.</p>"},{"location":"api/commands/capabilities_exchange/#diameter.message.commands.capabilities_exchange.VendorSpecificApplicationId.acct_application_id","title":"acct_application_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>acct_application_id: int = None\n</code></pre>"},{"location":"api/commands/capabilities_exchange/#diameter.message.commands.capabilities_exchange.VendorSpecificApplicationId.auth_application_id","title":"auth_application_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>auth_application_id: int = None\n</code></pre>"},{"location":"api/commands/capabilities_exchange/#diameter.message.commands.capabilities_exchange.VendorSpecificApplicationId.vendor_id","title":"vendor_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>vendor_id: int = None\n</code></pre>"},{"location":"api/commands/credit_control/","title":"Credit Control","text":"<p>API reference for <code>diameter.message.commands.credit_control</code>.</p> <p>Diameter Credit Control Application</p> <p>This module contains Credit Control Request and Answer messages, implementing AVPs documented in <code>rfc8506</code>, <code>rfc5777</code> and <code>rfc6733</code>.</p>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControl","title":"CreditControl","text":"<pre><code>CreditControl(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>DefinedMessage</code></p> <p>A Credit-Control message.</p> <p>This message class lists message attributes based on the current rfc8506 as python properties, acessible as instance attributes. AVPs not listed in the base protocol can be retrieved using the CreditControl.find_avps search method.</p> <p>Examples:</p> <p>AVPs accessible either as instance attributes or by searching:</p> <pre><code>&gt;&gt;&gt; msg = Message.from_bytes(b\"...\")\n&gt;&gt;&gt; msg.session_id\ndra1.mvno.net;2323;546\n&gt;&gt;&gt; msg.find_avps((AVP_SESSION_ID, 0))\n['dra1.mvno.net;2323;546']\n</code></pre> <p>When diameter message is decoded using Message.from_bytes, it returns either an instance of <code>CreditControlRequest</code> or <code>CreditControlAnswer</code> automatically:</p> <pre><code>&gt;&gt;&gt; msg = Message.from_bytes(b\"...\")\n&gt;&gt;&gt; assert msg.header.is_request is True\n&gt;&gt;&gt; assert isinstance(msg, CreditControlRequest)\n</code></pre> <p>When creating a new message, the <code>CreditControlRequest</code> or <code>CreditControlAnswer</code> class should be instantiated directly, and values for AVPs set as class attributes:</p> <pre><code>&gt;&gt;&gt; msg = CreditControlRequest()\n&gt;&gt;&gt; msg.session_id = \"dra1.mvno.net;2323;546\"\n</code></pre> <p>Other, custom AVPs can be appended to the message using the CreditControl.append_avp method, or by overwriting the <code>avp</code> attribute entirely. Regardless of the custom AVPs set, the mandatory values listed in RFC6733 must be set, however they can be set as <code>None</code>, if they are not to be used.</p> <p>Warning</p> <p>Every AVP documented for the subclasses of this command can be accessed as an instance attribute, even if the original network-received message did not contain that specific AVP. Such AVPs will be returned with the value <code>None</code> when accessed.</p> <p>Every other AVP not mentioned here, and not present in a network-received message will raise an <code>AttributeError</code> when being accessed; their presence should be validated with <code>hasattr</code> before accessing.</p>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlAnswer","title":"CreditControlAnswer","text":"<pre><code>CreditControlAnswer(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>CreditControl</code></p> <p>A Credit-Control-Answer message.</p> <p>Note</p> <p>This message class lacks the \"QoS-Final-Unit-Indication\" AVP as a class attribute. If the AVP is required, it must be constructed by hand and appended to the <code>additional_avps</code> attribute.</p>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlAnswer.acct_multi_session_id","title":"acct_multi_session_id  <code>instance-attribute</code>","text":"<pre><code>acct_multi_session_id: bytes\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlAnswer.auth_application_id","title":"auth_application_id  <code>instance-attribute</code>","text":"<pre><code>auth_application_id: int\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlAnswer.cc_request_number","title":"cc_request_number  <code>instance-attribute</code>","text":"<pre><code>cc_request_number: int\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlAnswer.cc_request_type","title":"cc_request_type  <code>instance-attribute</code>","text":"<pre><code>cc_request_type: int\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlAnswer.cc_session_failover","title":"cc_session_failover  <code>instance-attribute</code>","text":"<pre><code>cc_session_failover: int\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlAnswer.cc_sub_session_id","title":"cc_sub_session_id  <code>instance-attribute</code>","text":"<pre><code>cc_sub_session_id: int\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlAnswer.check_balance_result","title":"check_balance_result  <code>instance-attribute</code>","text":"<pre><code>check_balance_result: int\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlAnswer.cost_information","title":"cost_information  <code>instance-attribute</code>","text":"<pre><code>cost_information: CostInformation\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlAnswer.credit_control_failure_handling","title":"credit_control_failure_handling  <code>instance-attribute</code>","text":"<pre><code>credit_control_failure_handling: int\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlAnswer.direct_debiting_failure_handling","title":"direct_debiting_failure_handling  <code>instance-attribute</code>","text":"<pre><code>direct_debiting_failure_handling: int\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlAnswer.event_timestamp","title":"event_timestamp  <code>instance-attribute</code>","text":"<pre><code>event_timestamp: datetime.datetime\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlAnswer.failed_avp","title":"failed_avp  <code>instance-attribute</code>","text":"<pre><code>failed_avp: list[FailedAvp]\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlAnswer.final_unit_indication","title":"final_unit_indication  <code>instance-attribute</code>","text":"<pre><code>final_unit_indication: FinalUnitIndication\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlAnswer.granted_service_unit","title":"granted_service_unit  <code>instance-attribute</code>","text":"<pre><code>granted_service_unit: GrantedServiceUnit\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlAnswer.multiple_services_credit_control","title":"multiple_services_credit_control  <code>instance-attribute</code>","text":"<pre><code>multiple_services_credit_control: list[MultipleServicesCreditControl]\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlAnswer.origin_host","title":"origin_host  <code>instance-attribute</code>","text":"<pre><code>origin_host: bytes\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlAnswer.origin_realm","title":"origin_realm  <code>instance-attribute</code>","text":"<pre><code>origin_realm: bytes\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlAnswer.origin_state_id","title":"origin_state_id  <code>instance-attribute</code>","text":"<pre><code>origin_state_id: int\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlAnswer.proxy_info","title":"proxy_info  <code>instance-attribute</code>","text":"<pre><code>proxy_info: list[ProxyInfo]\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlAnswer.qos_final_unit_indication","title":"qos_final_unit_indication  <code>instance-attribute</code>","text":"<pre><code>qos_final_unit_indication: QosFinalUnitIndication\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlAnswer.redirect_host","title":"redirect_host  <code>instance-attribute</code>","text":"<pre><code>redirect_host: list[str]\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlAnswer.redirect_host_usage","title":"redirect_host_usage  <code>instance-attribute</code>","text":"<pre><code>redirect_host_usage: int\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlAnswer.redirect_max_cache_time","title":"redirect_max_cache_time  <code>instance-attribute</code>","text":"<pre><code>redirect_max_cache_time: int\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlAnswer.result_code","title":"result_code  <code>instance-attribute</code>","text":"<pre><code>result_code: int\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlAnswer.route_record","title":"route_record  <code>instance-attribute</code>","text":"<pre><code>route_record: list[bytes]\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlAnswer.session_id","title":"session_id  <code>instance-attribute</code>","text":"<pre><code>session_id: str\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlAnswer.user_name","title":"user_name  <code>instance-attribute</code>","text":"<pre><code>user_name: str\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlAnswer.validity_time","title":"validity_time  <code>instance-attribute</code>","text":"<pre><code>validity_time: int\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlAnswer.add_multiple_services_credit_control","title":"add_multiple_services_credit_control","text":"<pre><code>add_multiple_services_credit_control(granted_service_unit: GrantedServiceUnit = None, requested_service_unit: RequestedServiceUnit = None, used_service_unit: list[UsedServiceUnit] | UsedServiceUnit = None, tariff_change_usage: int = None, service_identifier: list[int] | int = None, rating_group: int = None, g_s_u_pool_reference: list[GsuPoolReference] = None, validity_time: int = None, result_code: int = None, final_unit_indication: FinalUnitIndication = None, avp: list[Avp] = None)\n</code></pre> <p>Add a multiple services credit control instance to the answer.</p> <p>This is identical to doing:</p> <pre><code>&gt;&gt;&gt; ccr = CreditControlAnswer()\n&gt;&gt;&gt; ccr.multiple_services_credit_control.append(\n&gt;&gt;&gt;     MultipleServicesCreditControl()\n&gt;&gt;&gt; )\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>granted_service_unit</code> <code>GrantedServiceUnit</code> <p>Optional granted service units</p> <code>None</code> <code>requested_service_unit</code> <code>RequestedServiceUnit</code> <p>Optional requested service units</p> <code>None</code> <code>used_service_unit</code> <code>list[UsedServiceUnit] | UsedServiceUnit</code> <p>Optional reported used service units</p> <code>None</code> <code>tariff_change_usage</code> <code>int</code> <p>Optional tariff changed usage indication</p> <code>None</code> <code>service_identifier</code> <code>list[int] | int</code> <p>A list of service identifiers</p> <code>None</code> <code>rating_group</code> <code>int</code> <p>An optional rating group identifier</p> <code>None</code> <code>g_s_u_pool_reference</code> <code>list[GsuPoolReference]</code> <p>An optional list of G-S-U-Pool references</p> <code>None</code> <code>validity_time</code> <code>int</code> <p>Validity time in seconds</p> <code>None</code> <code>result_code</code> <code>int</code> <p>A sub-result code for this specific MSCC</p> <code>None</code> <code>final_unit_indication</code> <code>FinalUnitIndication</code> <p>An optional final unit indiciation</p> <code>None</code> <code>avp</code> <code>list[Avp]</code> <p>A list of custom AVPs to attach</p> <code>None</code>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlRequest","title":"CreditControlRequest","text":"<pre><code>CreditControlRequest(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>CreditControl</code></p> <p>A Credit-Control-Request message.</p>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlRequest.acct_multi_session_id","title":"acct_multi_session_id  <code>instance-attribute</code>","text":"<pre><code>acct_multi_session_id: bytes\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlRequest.auth_application_id","title":"auth_application_id  <code>instance-attribute</code>","text":"<pre><code>auth_application_id: int\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlRequest.cc_correlation_id","title":"cc_correlation_id  <code>instance-attribute</code>","text":"<pre><code>cc_correlation_id: bytes\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlRequest.cc_request_number","title":"cc_request_number  <code>instance-attribute</code>","text":"<pre><code>cc_request_number: int\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlRequest.cc_request_type","title":"cc_request_type  <code>instance-attribute</code>","text":"<pre><code>cc_request_type: int\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlRequest.cc_sub_session_id","title":"cc_sub_session_id  <code>instance-attribute</code>","text":"<pre><code>cc_sub_session_id: int\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlRequest.destination_host","title":"destination_host  <code>instance-attribute</code>","text":"<pre><code>destination_host: bytes\n</code></pre> <p>Destination peer; should not be set for CCR-I, but should be set for  the subsequent requests, based on the CCR-I answer.</p>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlRequest.destination_realm","title":"destination_realm  <code>instance-attribute</code>","text":"<pre><code>destination_realm: bytes\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlRequest.event_timestamp","title":"event_timestamp  <code>instance-attribute</code>","text":"<pre><code>event_timestamp: datetime.datetime\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlRequest.multiple_services_credit_control","title":"multiple_services_credit_control  <code>instance-attribute</code>","text":"<pre><code>multiple_services_credit_control: list[MultipleServicesCreditControl]\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlRequest.multiple_services_indicator","title":"multiple_services_indicator  <code>instance-attribute</code>","text":"<pre><code>multiple_services_indicator: int\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlRequest.origin_host","title":"origin_host  <code>instance-attribute</code>","text":"<pre><code>origin_host: bytes\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlRequest.origin_realm","title":"origin_realm  <code>instance-attribute</code>","text":"<pre><code>origin_realm: bytes\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlRequest.origin_state_id","title":"origin_state_id  <code>instance-attribute</code>","text":"<pre><code>origin_state_id: int\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlRequest.proxy_info","title":"proxy_info  <code>instance-attribute</code>","text":"<pre><code>proxy_info: list[ProxyInfo]\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlRequest.requested_action","title":"requested_action  <code>instance-attribute</code>","text":"<pre><code>requested_action: int\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlRequest.requested_service_unit","title":"requested_service_unit  <code>instance-attribute</code>","text":"<pre><code>requested_service_unit: RequestedServiceUnit\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlRequest.route_record","title":"route_record  <code>instance-attribute</code>","text":"<pre><code>route_record: list[bytes]\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlRequest.service_context_id","title":"service_context_id  <code>instance-attribute</code>","text":"<pre><code>service_context_id: str\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlRequest.service_identifier","title":"service_identifier  <code>instance-attribute</code>","text":"<pre><code>service_identifier: int\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlRequest.service_parameter_info","title":"service_parameter_info  <code>instance-attribute</code>","text":"<pre><code>service_parameter_info: list[ServiceParameterInfo]\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlRequest.session_id","title":"session_id  <code>instance-attribute</code>","text":"<pre><code>session_id: str\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlRequest.subscription_id","title":"subscription_id  <code>instance-attribute</code>","text":"<pre><code>subscription_id: list[SubscriptionId]\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlRequest.termination_cause","title":"termination_cause  <code>instance-attribute</code>","text":"<pre><code>termination_cause: int\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlRequest.used_service_unit","title":"used_service_unit  <code>instance-attribute</code>","text":"<pre><code>used_service_unit: list[UsedServiceUnit]\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlRequest.user_equipment_info","title":"user_equipment_info  <code>instance-attribute</code>","text":"<pre><code>user_equipment_info: UserEquipmentInfo\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlRequest.user_equipment_info_extension","title":"user_equipment_info_extension  <code>instance-attribute</code>","text":"<pre><code>user_equipment_info_extension: UserEquipmentInfoExtension\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlRequest.user_name","title":"user_name  <code>instance-attribute</code>","text":"<pre><code>user_name: str\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlRequest.add_multiple_services_credit_control","title":"add_multiple_services_credit_control","text":"<pre><code>add_multiple_services_credit_control(granted_service_unit: GrantedServiceUnit = None, requested_service_unit: RequestedServiceUnit = None, used_service_unit: list[UsedServiceUnit] | UsedServiceUnit = None, tariff_change_usage: int = None, service_identifier: list[int] | int = None, rating_group: int = None, g_s_u_pool_reference: list[GsuPoolReference] = None, validity_time: int = None, result_code: int = None, final_unit_indication: FinalUnitIndication = None, avp: list[Avp] = None)\n</code></pre> <p>Add a multiple services credit control instance to the request.</p> <p>This is identical to doing:</p> <pre><code>&gt;&gt;&gt; ccr = CreditControlRequest()\n&gt;&gt;&gt; ccr.multiple_services_credit_control.append(\n&gt;&gt;&gt;     MultipleServicesCreditControl()\n&gt;&gt;&gt; )\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>granted_service_unit</code> <code>GrantedServiceUnit</code> <p>Optional granted service units</p> <code>None</code> <code>requested_service_unit</code> <code>RequestedServiceUnit</code> <p>Optional requested service units</p> <code>None</code> <code>used_service_unit</code> <code>list[UsedServiceUnit] | UsedServiceUnit</code> <p>Optional reported used service units</p> <code>None</code> <code>tariff_change_usage</code> <code>int</code> <p>Optional tariff changed usage indication</p> <code>None</code> <code>service_identifier</code> <code>list[int] | int</code> <p>A list of service identifiers</p> <code>None</code> <code>rating_group</code> <code>int</code> <p>An optional rating group identifier</p> <code>None</code> <code>g_s_u_pool_reference</code> <code>list[GsuPoolReference]</code> <p>An optional list of G-S-U-Pool references</p> <code>None</code> <code>validity_time</code> <code>int</code> <p>Validity time in seconds</p> <code>None</code> <code>result_code</code> <code>int</code> <p>A sub-result code for this specific MSCC</p> <code>None</code> <code>final_unit_indication</code> <code>FinalUnitIndication</code> <p>An optional final unit indiciation</p> <code>None</code> <code>avp</code> <code>list[Avp]</code> <p>A list of custom AVPs to attach</p> <code>None</code>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CreditControlRequest.add_subscription_id","title":"add_subscription_id","text":"<pre><code>add_subscription_id(subscription_id_type: int, subscription_id_data: str)\n</code></pre> <p>Add a subscription ID to the request.</p> <p>Parameters:</p> Name Type Description Default <code>subscription_id_type</code> <code>int</code> <p>One of the <code>E_SUBSCRIPTION_ID_TYPE_*</code> constant values</p> required <code>subscription_id_data</code> <code>str</code> <p>Actual subscription ID</p> required"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CostInformation","title":"CostInformation  <code>dataclass</code>","text":"<p>A data container that represents the \"Cost-Information\" grouped AVP.</p>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CostInformation.cost_unit","title":"cost_unit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cost_unit: str = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CostInformation.currency_code","title":"currency_code  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>currency_code: int = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.CostInformation.unit_value","title":"unit_value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>unit_value: UnitValue = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.FinalUnitIndication","title":"FinalUnitIndication  <code>dataclass</code>","text":"<p>A data container that represents the \"Final-Unit-Indication\" grouped AVP.</p> <p>This data container also has the <code>additional_avps</code> attribute, which permits appending custom AVPs to the Final-Unit-Indication, even though <code>rfc8560</code> doesn't actually permit it.</p>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.FinalUnitIndication.additional_avps","title":"additional_avps  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>additional_avps: list[Avp] = dataclasses.field(default_factory=list)\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.FinalUnitIndication.filter_id","title":"filter_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>filter_id: list[str] = dataclasses.field(default_factory=list)\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.FinalUnitIndication.final_unit_action","title":"final_unit_action  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>final_unit_action: int = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.FinalUnitIndication.redirect_server","title":"redirect_server  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>redirect_server: RedirectServer = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.FinalUnitIndication.restriction_filter_rule","title":"restriction_filter_rule  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>restriction_filter_rule: list[bytes] = dataclasses.field(default_factory=list)\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.GrantedServiceUnit","title":"GrantedServiceUnit  <code>dataclass</code>","text":"<p>A data container that represents the \"Granted-Service-Unit\" grouped AVP.</p>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.GrantedServiceUnit.cc_input_octets","title":"cc_input_octets  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cc_input_octets: int = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.GrantedServiceUnit.cc_money","title":"cc_money  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cc_money: CcMoney = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.GrantedServiceUnit.cc_service_specific_units","title":"cc_service_specific_units  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cc_service_specific_units: int = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.GrantedServiceUnit.cc_time","title":"cc_time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cc_time: int = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.GrantedServiceUnit.cc_total_octets","title":"cc_total_octets  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cc_total_octets: int = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.GsuPoolReference","title":"GsuPoolReference  <code>dataclass</code>","text":"<p>A data container that represents the \"G-S-U-Pool-Reference\" grouped AVP.</p>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.GsuPoolReference.cc_unit_type","title":"cc_unit_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cc_unit_type: int = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.GsuPoolReference.g_s_u_pool_identifier","title":"g_s_u_pool_identifier  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>g_s_u_pool_identifier: int = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.GsuPoolReference.unit_value","title":"unit_value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>unit_value: UnitValue = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.MultipleServicesCreditControl","title":"MultipleServicesCreditControl  <code>dataclass</code>","text":"<p>A data container that represents the \"Multiple-Services-Credit-Control\" grouped AVP.</p>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.MultipleServicesCreditControl.additional_avps","title":"additional_avps  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>additional_avps: list[Avp] = dataclasses.field(default_factory=list)\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.MultipleServicesCreditControl.final_unit_indication","title":"final_unit_indication  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>final_unit_indication: FinalUnitIndication = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.MultipleServicesCreditControl.g_s_u_pool_reference","title":"g_s_u_pool_reference  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>g_s_u_pool_reference: list[GsuPoolReference] = dataclasses.field(default_factory=list)\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.MultipleServicesCreditControl.granted_service_unit","title":"granted_service_unit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>granted_service_unit: GrantedServiceUnit = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.MultipleServicesCreditControl.rating_group","title":"rating_group  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rating_group: int = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.MultipleServicesCreditControl.requested_service_unit","title":"requested_service_unit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requested_service_unit: RequestedServiceUnit = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.MultipleServicesCreditControl.result_code","title":"result_code  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result_code: int = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.MultipleServicesCreditControl.service_identifier","title":"service_identifier  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>service_identifier: list[int] = dataclasses.field(default_factory=list)\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.MultipleServicesCreditControl.tariff_change_usage","title":"tariff_change_usage  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tariff_change_usage: int = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.MultipleServicesCreditControl.used_service_unit","title":"used_service_unit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>used_service_unit: list[UsedServiceUnit] = dataclasses.field(default_factory=list)\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.MultipleServicesCreditControl.validity_time","title":"validity_time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>validity_time: int = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.ProxyInfo","title":"ProxyInfo  <code>dataclass</code>","text":"<p>A data container that represents the \"Proxy-Info\" grouped AVP.</p>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.ProxyInfo.proxy_host","title":"proxy_host  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>proxy_host: bytes = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.ProxyInfo.proxy_state","title":"proxy_state  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>proxy_state: bytes = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.RequestedServiceUnit","title":"RequestedServiceUnit  <code>module-attribute</code>","text":"<pre><code>RequestedServiceUnit = GrantedServiceUnit\n</code></pre> <p>A data container that represents the \"Requested-Service-Unit\" grouped AVP.</p> <p>This is an alias for \"Granted-Service-Unit\", as they both are technically  identical.</p>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.ServiceParameterInfo","title":"ServiceParameterInfo  <code>dataclass</code>","text":"<p>A data container that represents the \"Service-Parameter-Info\" grouped AVP.</p>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.ServiceParameterInfo.service_parameter_type","title":"service_parameter_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>service_parameter_type: int = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.ServiceParameterInfo.service_parameter_value","title":"service_parameter_value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>service_parameter_value: bytes = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.SubscriptionId","title":"SubscriptionId  <code>dataclass</code>","text":"<p>A data container that represents the \"Subscription-ID\" grouped AVP.</p>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.SubscriptionId.subscription_id_data","title":"subscription_id_data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>subscription_id_data: str = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.SubscriptionId.subscription_id_type","title":"subscription_id_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>subscription_id_type: int = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.UsedServiceUnit","title":"UsedServiceUnit  <code>dataclass</code>","text":"<p>A data container that represents the \"Used-Service-Unit\" grouped AVP.</p>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.UsedServiceUnit.cc_input_octets","title":"cc_input_octets  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cc_input_octets: int = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.UsedServiceUnit.cc_money","title":"cc_money  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cc_money: CcMoney = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.UsedServiceUnit.cc_output_octets","title":"cc_output_octets  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cc_output_octets: int = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.UsedServiceUnit.cc_service_specific_units","title":"cc_service_specific_units  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cc_service_specific_units: int = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.UsedServiceUnit.cc_time","title":"cc_time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cc_time: int = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.UsedServiceUnit.cc_total_octets","title":"cc_total_octets  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cc_total_octets: int = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.UsedServiceUnit.tariff_change_usage","title":"tariff_change_usage  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tariff_change_usage: int = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.UserEquipmentInfo","title":"UserEquipmentInfo  <code>dataclass</code>","text":"<p>A data container that represents the \"User-Equipment-Info\" grouped AVP.</p>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.UserEquipmentInfo.user_equipment_info_type","title":"user_equipment_info_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>user_equipment_info_type: int = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.UserEquipmentInfo.user_equipment_info_value","title":"user_equipment_info_value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>user_equipment_info_value: bytes = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.UserEquipmentInfoExtension","title":"UserEquipmentInfoExtension  <code>dataclass</code>","text":"<p>A data container that represents the \"User-Equipment-Info-Extension\" grouped AVP.</p>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.UserEquipmentInfoExtension.user_equipment_info_eui64","title":"user_equipment_info_eui64  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>user_equipment_info_eui64: bytes = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.UserEquipmentInfoExtension.user_equipment_info_imei","title":"user_equipment_info_imei  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>user_equipment_info_imei: bytes = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.UserEquipmentInfoExtension.user_equipment_info_imeisv","title":"user_equipment_info_imeisv  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>user_equipment_info_imeisv: bytes = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.UserEquipmentInfoExtension.user_equipment_info_mac","title":"user_equipment_info_mac  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>user_equipment_info_mac: bytes = None\n</code></pre>"},{"location":"api/commands/credit_control/#diameter.message.commands.credit_control.UserEquipmentInfoExtension.user_equipment_info_modifiedeui64","title":"user_equipment_info_modifiedeui64  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>user_equipment_info_modifiedeui64: bytes = None\n</code></pre>"},{"location":"api/commands/device_watchdog/","title":"Device Watchdog","text":"<p>API reference for <code>diameter.message.commands.device_watchdog</code>.</p> <p>This module contains Device Watchdog Request and Answer messages, implementing AVPs documented in rfc6733.</p>"},{"location":"api/commands/device_watchdog/#diameter.message.commands.device_watchdog.DeviceWatchdog","title":"DeviceWatchdog","text":"<pre><code>DeviceWatchdog(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>DefinedMessage</code></p> <p>A Device-Watchdog message.</p> <p>This message class lists message attributes based on the current RFC6733 as python properties, acessible as instance attributes. AVPs not listed in the base protocol can be retrieved using the DeviceWatchdog.find_avps search method.</p> <p>Examples:</p> <p>AVPs accessible either as instance attributes or by searching:</p> <pre><code>&gt;&gt;&gt; msg = Message.from_bytes(b\"...\")\n&gt;&gt;&gt; msg.origin_realm\nb'mvno.net'\n&gt;&gt;&gt; msg.find_avps((AVP_ORIGIN_REALM, 0))\n[b'mvno.net']\n</code></pre> <p>When diameter message is decoded using Message.from_bytes, it returns either an instance of <code>DeviceWatchdogRequest</code> or <code>DeviceWatchdogAnswer</code> automatically:</p> <pre><code>&gt;&gt;&gt; msg = Message.from_bytes(b\"...\")\n&gt;&gt;&gt; assert msg.header.is_request is True\n&gt;&gt;&gt; assert isinstance(msg, DeviceWatchdogRequest)\n</code></pre> <p>When creating a new message, the <code>DeviceWatchdogRequest</code> or <code>DeviceWatchdogAnswer</code> class should be instantiated directly, and values for AVPs set as class attributes:</p> <pre><code>&gt;&gt;&gt; msg = DeviceWatchdogRequest()\n&gt;&gt;&gt; msg.origin_realm = b\"mvno.net\"\n</code></pre> <p>Other, custom AVPs can be appended to the message using the DeviceWatchdog.append_avp method, or by overwriting the <code>avp</code> attribute entirely. Regardless of the custom AVPs set, the mandatory values listed in RFC6733 must be set, however they can be set as <code>None</code>, if they are not to be used.</p> <p>Warning</p> <p>Every AVP documented for the subclasses of this command can be accessed as an instance attribute, even if the original network-received message did not contain that specific AVP. Such AVPs will be returned with the value <code>None</code> when accessed.</p> <p>Every other AVP not mentioned here, and not present in a network-received message will raise an <code>AttributeError</code> when being accessed; their presence should be validated with <code>hasattr</code> before accessing.</p>"},{"location":"api/commands/device_watchdog/#diameter.message.commands.device_watchdog.DeviceWatchdogAnswer","title":"DeviceWatchdogAnswer","text":"<pre><code>DeviceWatchdogAnswer(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>DeviceWatchdog</code></p> <p>A Device-Watchdog-Answer message.</p>"},{"location":"api/commands/device_watchdog/#diameter.message.commands.device_watchdog.DeviceWatchdogAnswer.error_message","title":"error_message  <code>instance-attribute</code>","text":"<pre><code>error_message: str\n</code></pre>"},{"location":"api/commands/device_watchdog/#diameter.message.commands.device_watchdog.DeviceWatchdogAnswer.failed_avp","title":"failed_avp  <code>instance-attribute</code>","text":"<pre><code>failed_avp: FailedAvp\n</code></pre>"},{"location":"api/commands/device_watchdog/#diameter.message.commands.device_watchdog.DeviceWatchdogAnswer.origin_host","title":"origin_host  <code>instance-attribute</code>","text":"<pre><code>origin_host: bytes\n</code></pre>"},{"location":"api/commands/device_watchdog/#diameter.message.commands.device_watchdog.DeviceWatchdogAnswer.origin_realm","title":"origin_realm  <code>instance-attribute</code>","text":"<pre><code>origin_realm: bytes\n</code></pre>"},{"location":"api/commands/device_watchdog/#diameter.message.commands.device_watchdog.DeviceWatchdogAnswer.origin_state_id","title":"origin_state_id  <code>instance-attribute</code>","text":"<pre><code>origin_state_id: int\n</code></pre>"},{"location":"api/commands/device_watchdog/#diameter.message.commands.device_watchdog.DeviceWatchdogAnswer.result_code","title":"result_code  <code>instance-attribute</code>","text":"<pre><code>result_code: int\n</code></pre>"},{"location":"api/commands/device_watchdog/#diameter.message.commands.device_watchdog.DeviceWatchdogRequest","title":"DeviceWatchdogRequest","text":"<pre><code>DeviceWatchdogRequest(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>DeviceWatchdog</code></p> <p>A Device-Watchdog-Request message.</p>"},{"location":"api/commands/device_watchdog/#diameter.message.commands.device_watchdog.DeviceWatchdogRequest.origin_host","title":"origin_host  <code>instance-attribute</code>","text":"<pre><code>origin_host: bytes\n</code></pre>"},{"location":"api/commands/device_watchdog/#diameter.message.commands.device_watchdog.DeviceWatchdogRequest.origin_realm","title":"origin_realm  <code>instance-attribute</code>","text":"<pre><code>origin_realm: bytes\n</code></pre>"},{"location":"api/commands/device_watchdog/#diameter.message.commands.device_watchdog.DeviceWatchdogRequest.origin_state_id","title":"origin_state_id  <code>instance-attribute</code>","text":"<pre><code>origin_state_id: int\n</code></pre>"},{"location":"api/commands/device_watchdog/#diameter.message.commands.device_watchdog.FailedAvp","title":"FailedAvp  <code>dataclass</code>","text":"<p>A data container that represents the \"Failed-AVP\" grouped AVP.</p> <p><code>rfc6733</code>, defines this as just a list of arbitrary AVPs; the actual failed AVPs should be copied into the <code>additional_avps</code> attribute.</p>"},{"location":"api/commands/device_watchdog/#diameter.message.commands.device_watchdog.FailedAvp.additional_avps","title":"additional_avps  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>additional_avps: list[Avp] = dataclasses.field(default_factory=list)\n</code></pre>"},{"location":"api/commands/disconnect_peer/","title":"Disconnect Peer","text":"<p>API reference for <code>diameter.message.commands.disconnect_peer</code>.</p> <p>This module contains Disconnect-PeerConnection Request and Answer messages, implementing AVPs documented in rfc6733.</p>"},{"location":"api/commands/disconnect_peer/#diameter.message.commands.disconnect_peer.DisconnectPeer","title":"DisconnectPeer","text":"<pre><code>DisconnectPeer(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>DefinedMessage</code></p> <p>A Disconnect-Peer message.</p> <p>This message class lists message attributes based on the current RFC6733 as python properties, acessible as instance attributes. AVPs not listed in the base protocol can be retrieved using the DisconnectPeer.find_avps search method.</p> <p>Examples:</p> <p>AVPs accessible either as instance attributes or by searching:</p> <pre><code>&gt;&gt;&gt; msg = Message.from_bytes(b\"...\")\n&gt;&gt;&gt; msg.origin_realm\nb'mvno.net'\n&gt;&gt;&gt; msg.find_avps((AVP_ORIGIN_REALM, 0))\n[b'mvno.net']\n</code></pre> <p>When diameter message is decoded using Message.from_bytes, it returns either an instance of <code>DisconnectPeerRequest</code> or <code>DisconnectPeerAnswer</code> automatically:</p> <pre><code>&gt;&gt;&gt; msg = Message.from_bytes(b\"...\")\n&gt;&gt;&gt; assert msg.header.is_request is True\n&gt;&gt;&gt; assert isinstance(msg, DisconnectPeerRequest)\n</code></pre> <p>When creating a new message, the <code>DisconnectPeerRequest</code> or <code>DisconnectPeerAnswer</code> class should be instantiated directly, and values for AVPs set as class attributes:</p> <pre><code>&gt;&gt;&gt; msg = DisconnectPeerRequest()\n&gt;&gt;&gt; msg.origin_realm = b\"mvno.net\"\n</code></pre> <p>Other, custom AVPs can be appended to the message using the DisconnectPeer.append_avp method, or by overwriting the <code>avp</code> attribute entirely. Regardless of the custom AVPs set, the mandatory values listed in RFC6733 must be set, however they can be set as <code>None</code>, if they are not to be used.</p> <p>Warning</p> <p>Every AVP documented for the subclasses of this command can be accessed as an instance attribute, even if the original network-received message did not contain that specific AVP. Such AVPs will be returned with the value <code>None</code> when accessed.</p> <p>Every other AVP not mentioned here, and not present in a network-received message will raise an <code>AttributeError</code> when being accessed; their presence should be validated with <code>hasattr</code> before accessing.</p>"},{"location":"api/commands/disconnect_peer/#diameter.message.commands.disconnect_peer.DisconnectPeerAnswer","title":"DisconnectPeerAnswer","text":"<pre><code>DisconnectPeerAnswer(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>DisconnectPeer</code></p> <p>A Disconnect-Peer-Answer message.</p>"},{"location":"api/commands/disconnect_peer/#diameter.message.commands.disconnect_peer.DisconnectPeerAnswer.error_message","title":"error_message  <code>instance-attribute</code>","text":"<pre><code>error_message: str\n</code></pre>"},{"location":"api/commands/disconnect_peer/#diameter.message.commands.disconnect_peer.DisconnectPeerAnswer.failed_avp","title":"failed_avp  <code>instance-attribute</code>","text":"<pre><code>failed_avp: FailedAvp\n</code></pre>"},{"location":"api/commands/disconnect_peer/#diameter.message.commands.disconnect_peer.DisconnectPeerAnswer.origin_host","title":"origin_host  <code>instance-attribute</code>","text":"<pre><code>origin_host: bytes\n</code></pre>"},{"location":"api/commands/disconnect_peer/#diameter.message.commands.disconnect_peer.DisconnectPeerAnswer.origin_realm","title":"origin_realm  <code>instance-attribute</code>","text":"<pre><code>origin_realm: bytes\n</code></pre>"},{"location":"api/commands/disconnect_peer/#diameter.message.commands.disconnect_peer.DisconnectPeerAnswer.result_code","title":"result_code  <code>instance-attribute</code>","text":"<pre><code>result_code: int\n</code></pre>"},{"location":"api/commands/disconnect_peer/#diameter.message.commands.disconnect_peer.DisconnectPeerRequest","title":"DisconnectPeerRequest","text":"<pre><code>DisconnectPeerRequest(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>DisconnectPeer</code></p> <p>A Disconnect-Peer-Request message.</p>"},{"location":"api/commands/disconnect_peer/#diameter.message.commands.disconnect_peer.DisconnectPeerRequest.disconnect_cause","title":"disconnect_cause  <code>instance-attribute</code>","text":"<pre><code>disconnect_cause: bytes\n</code></pre>"},{"location":"api/commands/disconnect_peer/#diameter.message.commands.disconnect_peer.DisconnectPeerRequest.origin_host","title":"origin_host  <code>instance-attribute</code>","text":"<pre><code>origin_host: bytes\n</code></pre>"},{"location":"api/commands/disconnect_peer/#diameter.message.commands.disconnect_peer.DisconnectPeerRequest.origin_realm","title":"origin_realm  <code>instance-attribute</code>","text":"<pre><code>origin_realm: bytes\n</code></pre>"},{"location":"api/commands/disconnect_peer/#diameter.message.commands.disconnect_peer.FailedAvp","title":"FailedAvp  <code>dataclass</code>","text":"<p>A data container that represents the \"Failed-AVP\" grouped AVP.</p> <p><code>rfc6733</code>, defines this as just a list of arbitrary AVPs; the actual failed AVPs should be copied into the <code>additional_avps</code> attribute.</p>"},{"location":"api/commands/disconnect_peer/#diameter.message.commands.disconnect_peer.FailedAvp.additional_avps","title":"additional_avps  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>additional_avps: list[Avp] = dataclasses.field(default_factory=list)\n</code></pre>"},{"location":"api/commands/other_commands/","title":"Other","text":"<p>API reference for <code>diameter.message.commands</code>.</p> <p>Placeholder classes that extend <code>Message</code>, but do not provide any direct python API for reading and setting AVPs.</p>"},{"location":"api/commands/other_commands/#diameter.message.commands.Aa","title":"Aa","text":"<pre><code>Aa(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>Message</code></p> <p>An AA message.</p> <p>This message implementation provides no python subclasses for requests and answers; AVPs must be created manually and added using the Aa.append_avp method.</p>"},{"location":"api/commands/other_commands/#diameter.message.commands.AaMobileNode","title":"AaMobileNode","text":"<pre><code>AaMobileNode(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>Message</code></p> <p>An AA-Mobile-Node message.</p> <p>This message implementation provides no python subclasses for requests and answers; AVPs must be created manually and added using the AaMobileNode.append_avp method.</p>"},{"location":"api/commands/other_commands/#diameter.message.commands.AuthenticationInformation","title":"AuthenticationInformation","text":"<pre><code>AuthenticationInformation(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>Message</code></p> <p>A 3GPP-Authentication-Information message.</p> <p>This message implementation provides no python subclasses for requests and answers; AVPs must be created manually and added using the AuthenticationInformation.append_avp method.</p>"},{"location":"api/commands/other_commands/#diameter.message.commands.BootstrapingInfo","title":"BootstrapingInfo","text":"<pre><code>BootstrapingInfo(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>Message</code></p> <p>A Bootstraping-Info message.</p> <p>This message implementation provides no python subclasses for requests and answers; AVPs must be created manually and added using the BootstrapingInfo.append_avp method.</p>"},{"location":"api/commands/other_commands/#diameter.message.commands.CancelLocation","title":"CancelLocation","text":"<pre><code>CancelLocation(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>Message</code></p> <p>A 3GPP-Cancel-Location message.</p> <p>This message implementation provides no python subclasses for requests and answers; AVPs must be created manually and added using the CancelLocation.append_avp method.</p>"},{"location":"api/commands/other_commands/#diameter.message.commands.DeleteSubscriberData","title":"DeleteSubscriberData","text":"<pre><code>DeleteSubscriberData(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>Message</code></p> <p>A 3GPP-Delete-Subscriber-Data message.</p> <p>This message implementation provides no python subclasses for requests and answers; AVPs must be created manually and added using the DeleteSubscriberData.append_avp method.</p>"},{"location":"api/commands/other_commands/#diameter.message.commands.DiameterEap","title":"DiameterEap","text":"<pre><code>DiameterEap(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>Message</code></p> <p>A Diameter-EAP message.</p> <p>This message implementation provides no python subclasses for requests and answers; AVPs must be created manually and added using the DiameterEap.append_avp method.</p>"},{"location":"api/commands/other_commands/#diameter.message.commands.HomeAgentMip","title":"HomeAgentMip","text":"<pre><code>HomeAgentMip(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>Message</code></p> <p>A Home-Agent-MIP message.</p> <p>This message implementation provides no python subclasses for requests and answers; AVPs must be created manually and added using the AaMobileNode.append_avp method.</p>"},{"location":"api/commands/other_commands/#diameter.message.commands.InsertSubscriberData","title":"InsertSubscriberData","text":"<pre><code>InsertSubscriberData(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>Message</code></p> <p>A 3GPP-Insert-Subscriber-Data message.</p> <p>This message implementation provides no python subclasses for requests and answers; AVPs must be created manually and added using the InsertSubscriberData.append_avp method.</p>"},{"location":"api/commands/other_commands/#diameter.message.commands.LocationInfo","title":"LocationInfo","text":"<pre><code>LocationInfo(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>Message</code></p> <p>A Location-Info message.</p> <p>This message implementation provides no python subclasses for requests and answers; AVPs must be created manually and added using the LocationInfo.append_avp method.</p>"},{"location":"api/commands/other_commands/#diameter.message.commands.MIp6","title":"MIp6","text":"<pre><code>MIp6(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>Message</code></p> <p>A MIP6 message.</p> <p>This message implementation provides no python subclasses for requests and answers; AVPs must be created manually and added using the MIp6.append_avp method.</p>"},{"location":"api/commands/other_commands/#diameter.message.commands.MeIdentityCheck","title":"MeIdentityCheck","text":"<pre><code>MeIdentityCheck(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>Message</code></p> <p>A 3GPP-ME-Identity-Check message.</p> <p>This message implementation provides no python subclasses for requests and answers; AVPs must be created manually and added using the AaMobileNode.append_avp method.</p>"},{"location":"api/commands/other_commands/#diameter.message.commands.MessageProcess","title":"MessageProcess","text":"<pre><code>MessageProcess(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>Message</code></p> <p>A Message-Process message.</p> <p>This message implementation provides no python subclasses for requests and answers; AVPs must be created manually and added using the MessageProcess.append_avp method.</p>"},{"location":"api/commands/other_commands/#diameter.message.commands.MultimediaAuth","title":"MultimediaAuth","text":"<pre><code>MultimediaAuth(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>Message</code></p> <p>A Multimedia-Auth message.</p> <p>This message implementation provides no python subclasses for requests and answers; AVPs must be created manually and added using the MultimediaAuth.append_avp method.</p>"},{"location":"api/commands/other_commands/#diameter.message.commands.Notify","title":"Notify","text":"<pre><code>Notify(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>Message</code></p> <p>A 3GPP-Notify message.</p> <p>This message implementation provides no python subclasses for requests and answers; AVPs must be created manually and added using the Notify.append_avp method.</p>"},{"location":"api/commands/other_commands/#diameter.message.commands.ProfileUpdate","title":"ProfileUpdate","text":"<pre><code>ProfileUpdate(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>Message</code></p> <p>A Profile-Update message.</p> <p>This message implementation provides no python subclasses for requests and answers; AVPs must be created manually and added using the ProfileUpdate.append_avp method.</p>"},{"location":"api/commands/other_commands/#diameter.message.commands.PurgeUE","title":"PurgeUE","text":"<pre><code>PurgeUE(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>Message</code></p> <p>A 3GPP-Purge-UE message.</p> <p>This message implementation provides no python subclasses for requests and answers; AVPs must be created manually and added using the PurgeUE.append_avp method.</p>"},{"location":"api/commands/other_commands/#diameter.message.commands.PushNotification","title":"PushNotification","text":"<pre><code>PushNotification(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>Message</code></p> <p>A Push-Notification message.</p> <p>This message implementation provides no python subclasses for requests and answers; AVPs must be created manually and added using the PushNotification.append_avp method.</p>"},{"location":"api/commands/other_commands/#diameter.message.commands.PushProfile","title":"PushProfile","text":"<pre><code>PushProfile(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>Message</code></p> <p>A Push-Profile message.</p> <p>This message implementation provides no python subclasses for requests and answers; AVPs must be created manually and added using the PushProfile.append_avp method.</p>"},{"location":"api/commands/other_commands/#diameter.message.commands.RegistrationTermination","title":"RegistrationTermination","text":"<pre><code>RegistrationTermination(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>Message</code></p> <p>A Registration-Termination message.</p> <p>This message implementation provides no python subclasses for requests and answers; AVPs must be created manually and added using the [AaMobileNode.append_avpRegistrationTerminationdiameter.message.Message.append_avp] method.</p>"},{"location":"api/commands/other_commands/#diameter.message.commands.Reset","title":"Reset","text":"<pre><code>Reset(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>Message</code></p> <p>A 3GPP-Reset message.</p> <p>This message implementation provides no python subclasses for requests and answers; AVPs must be created manually and added using the Reset.append_avp method.</p>"},{"location":"api/commands/other_commands/#diameter.message.commands.ServerAssignment","title":"ServerAssignment","text":"<pre><code>ServerAssignment(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>Message</code></p> <p>A Server-Assignment message.</p> <p>This message implementation provides no python subclasses for requests and answers; AVPs must be created manually and added using the ServerAssignment.append_avp method.</p>"},{"location":"api/commands/other_commands/#diameter.message.commands.SipLocationInfo","title":"SipLocationInfo","text":"<pre><code>SipLocationInfo(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>Message</code></p> <p>A SIP-Location-Info message.</p> <p>This message implementation provides no python subclasses for requests and answers; AVPs must be created manually and added using the SipLocationInfo.append_avp method.</p>"},{"location":"api/commands/other_commands/#diameter.message.commands.SipMultimediaAuth","title":"SipMultimediaAuth","text":"<pre><code>SipMultimediaAuth(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>Message</code></p> <p>A SIP-Multimedia-Auth message.</p> <p>This message implementation provides no python subclasses for requests and answers; AVPs must be created manually and added using the SipMultimediaAuth.append_avp method.</p>"},{"location":"api/commands/other_commands/#diameter.message.commands.SipPushProfile","title":"SipPushProfile","text":"<pre><code>SipPushProfile(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>Message</code></p> <p>A SIP-Push-Profile message.</p> <p>This message implementation provides no python subclasses for requests and answers; AVPs must be created manually and added using the SipPushProfile.append_avp method.</p>"},{"location":"api/commands/other_commands/#diameter.message.commands.SipRegistrationTermination","title":"SipRegistrationTermination","text":"<pre><code>SipRegistrationTermination(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>Message</code></p> <p>A SIP-Registration-Termination message.</p> <p>This message implementation provides no python subclasses for requests and answers; AVPs must be created manually and added using the SipRegistrationTermination.append_avp method.</p>"},{"location":"api/commands/other_commands/#diameter.message.commands.SipServerAssignment","title":"SipServerAssignment","text":"<pre><code>SipServerAssignment(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>Message</code></p> <p>A SIP-Server-Assignment message.</p> <p>This message implementation provides no python subclasses for requests and answers; AVPs must be created manually and added using the SipServerAssignment.append_avp method.</p>"},{"location":"api/commands/other_commands/#diameter.message.commands.SipUserAuthorization","title":"SipUserAuthorization","text":"<pre><code>SipUserAuthorization(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>Message</code></p> <p>A SIP-User-Authorization message.</p> <p>This message implementation provides no python subclasses for requests and answers; AVPs must be created manually and added using the SipUserAuthorization.append_avp method.</p>"},{"location":"api/commands/other_commands/#diameter.message.commands.SubscribeNotifications","title":"SubscribeNotifications","text":"<pre><code>SubscribeNotifications(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>Message</code></p> <p>A Subscribe-Notifications message.</p> <p>This message implementation provides no python subclasses for requests and answers; AVPs must be created manually and added using the SubscribeNotifications.append_avp method.</p>"},{"location":"api/commands/other_commands/#diameter.message.commands.UpdateLocation","title":"UpdateLocation","text":"<pre><code>UpdateLocation(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>Message</code></p> <p>A 3GPP-Update-Location message.</p> <p>This message implementation provides no python subclasses for requests and answers; AVPs must be created manually and added using the UpdateLocation.append_avp method.</p>"},{"location":"api/commands/other_commands/#diameter.message.commands.UserAuthorization","title":"UserAuthorization","text":"<pre><code>UserAuthorization(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>Message</code></p> <p>A User-Authorization message.</p> <p>This message implementation provides no python subclasses for requests and answers; AVPs must be created manually and added using the UserAuthorization.append_avp method.</p>"},{"location":"api/commands/other_commands/#diameter.message.commands.UserData","title":"UserData","text":"<pre><code>UserData(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>Message</code></p> <p>A User-Data message.</p> <p>This message implementation provides no python subclasses for requests and answers; AVPs must be created manually and added using the UserData.append_avp method.</p>"},{"location":"api/commands/re_auth/","title":"Re Auth","text":"<p>API reference for <code>diameter.message.commands.re_auth</code>.</p> <p>This module contains Re-Auth Request and Answer messages, implementing AVPs documented in rfc6733.</p>"},{"location":"api/commands/re_auth/#diameter.message.commands.re_auth.ReAuth","title":"ReAuth","text":"<pre><code>ReAuth(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>DefinedMessage</code></p> <p>A Re-Auth message.</p> <p>This message class lists message attributes based on the current RFC6733 as python properties, acessible as instance attributes. AVPs not listed in the base protocol can be retrieved using the ReAuth.find_avps search method.</p> <p>Examples:</p> <p>AVPs accessible either as instance attributes or by searching:</p> <pre><code>&gt;&gt;&gt; msg = Message.from_bytes(b\"...\")\n&gt;&gt;&gt; msg.origin_realm\nb'mvno.net'\n&gt;&gt;&gt; msg.find_avps((AVP_ORIGIN_REALM, 0))\n[b'mvno.net']\n</code></pre> <p>When a diameter message is decoded using Message.from_bytes, it returns either an instance of <code>ReAuthRequest</code> or <code>ReAuthAnswer</code> automatically:</p> <pre><code>&gt;&gt;&gt; msg = Message.from_bytes(b\"...\")\n&gt;&gt;&gt; assert msg.header.is_request is True\n&gt;&gt;&gt; assert isinstance(msg, ReAuthRequest)\n</code></pre> <p>When creating a new message by hand, the <code>ReAuthRequest</code> or <code>ReAuthAnswer</code> class should be instantiated directly, and values for AVPs set as class attributes:</p> <pre><code>&gt;&gt;&gt; msg = ReAuthRequest()\n&gt;&gt;&gt; msg.origin_realm = b\"mvno.net\"\n</code></pre> <p>Other, custom AVPs can be appended to the message using the ReAuth.append_avp method, or by overwriting the <code>avp</code> attribute entirely. Regardless of the custom AVPs set, the mandatory values listed in RFC6733 must be set, however they can be set as <code>None</code>, if they are not to be used.</p> <p>Warning</p> <p>Every AVP documented for the subclasses of this command can be accessed as an instance attribute, even if the original network-received message did not contain that specific AVP. Such AVPs will be returned with the value <code>None</code> when accessed.</p> <p>Every other AVP not mentioned here, and not present in a network-received message will raise an <code>AttributeError</code> when being accessed; their presence should be validated with <code>hasattr</code> before accessing.</p>"},{"location":"api/commands/re_auth/#diameter.message.commands.re_auth.ReAuthAnswer","title":"ReAuthAnswer","text":"<pre><code>ReAuthAnswer(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>ReAuth</code></p> <p>A Re-Auth-Answer message.</p>"},{"location":"api/commands/re_auth/#diameter.message.commands.re_auth.ReAuthAnswer.error_message","title":"error_message  <code>instance-attribute</code>","text":"<pre><code>error_message: str\n</code></pre>"},{"location":"api/commands/re_auth/#diameter.message.commands.re_auth.ReAuthAnswer.error_reporting_host","title":"error_reporting_host  <code>instance-attribute</code>","text":"<pre><code>error_reporting_host: bytes\n</code></pre>"},{"location":"api/commands/re_auth/#diameter.message.commands.re_auth.ReAuthAnswer.failed_avp","title":"failed_avp  <code>instance-attribute</code>","text":"<pre><code>failed_avp: FailedAvp\n</code></pre>"},{"location":"api/commands/re_auth/#diameter.message.commands.re_auth.ReAuthAnswer.origin_host","title":"origin_host  <code>instance-attribute</code>","text":"<pre><code>origin_host: bytes\n</code></pre>"},{"location":"api/commands/re_auth/#diameter.message.commands.re_auth.ReAuthAnswer.origin_realm","title":"origin_realm  <code>instance-attribute</code>","text":"<pre><code>origin_realm: bytes\n</code></pre>"},{"location":"api/commands/re_auth/#diameter.message.commands.re_auth.ReAuthAnswer.origin_state_id","title":"origin_state_id  <code>instance-attribute</code>","text":"<pre><code>origin_state_id: int\n</code></pre>"},{"location":"api/commands/re_auth/#diameter.message.commands.re_auth.ReAuthAnswer.proxy_info","title":"proxy_info  <code>instance-attribute</code>","text":"<pre><code>proxy_info: list[ProxyInfo]\n</code></pre>"},{"location":"api/commands/re_auth/#diameter.message.commands.re_auth.ReAuthAnswer.redirect_host","title":"redirect_host  <code>instance-attribute</code>","text":"<pre><code>redirect_host: list[str]\n</code></pre>"},{"location":"api/commands/re_auth/#diameter.message.commands.re_auth.ReAuthAnswer.redirect_host_usage","title":"redirect_host_usage  <code>instance-attribute</code>","text":"<pre><code>redirect_host_usage: int\n</code></pre>"},{"location":"api/commands/re_auth/#diameter.message.commands.re_auth.ReAuthAnswer.redirect_max_cache_time","title":"redirect_max_cache_time  <code>instance-attribute</code>","text":"<pre><code>redirect_max_cache_time: int\n</code></pre>"},{"location":"api/commands/re_auth/#diameter.message.commands.re_auth.ReAuthAnswer.result_code","title":"result_code  <code>instance-attribute</code>","text":"<pre><code>result_code: int\n</code></pre>"},{"location":"api/commands/re_auth/#diameter.message.commands.re_auth.ReAuthAnswer.route_record","title":"route_record  <code>instance-attribute</code>","text":"<pre><code>route_record: list[bytes]\n</code></pre>"},{"location":"api/commands/re_auth/#diameter.message.commands.re_auth.ReAuthAnswer.session_id","title":"session_id  <code>instance-attribute</code>","text":"<pre><code>session_id: str\n</code></pre>"},{"location":"api/commands/re_auth/#diameter.message.commands.re_auth.ReAuthAnswer.user_name","title":"user_name  <code>instance-attribute</code>","text":"<pre><code>user_name: str\n</code></pre>"},{"location":"api/commands/re_auth/#diameter.message.commands.re_auth.ReAuthRequest","title":"ReAuthRequest","text":"<pre><code>ReAuthRequest(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>ReAuth</code></p> <p>A Re-Auth-Request message.</p>"},{"location":"api/commands/re_auth/#diameter.message.commands.re_auth.ReAuthRequest.auth_application_id","title":"auth_application_id  <code>instance-attribute</code>","text":"<pre><code>auth_application_id: int\n</code></pre>"},{"location":"api/commands/re_auth/#diameter.message.commands.re_auth.ReAuthRequest.destination_host","title":"destination_host  <code>instance-attribute</code>","text":"<pre><code>destination_host: bytes\n</code></pre>"},{"location":"api/commands/re_auth/#diameter.message.commands.re_auth.ReAuthRequest.destination_realm","title":"destination_realm  <code>instance-attribute</code>","text":"<pre><code>destination_realm: bytes\n</code></pre>"},{"location":"api/commands/re_auth/#diameter.message.commands.re_auth.ReAuthRequest.origin_host","title":"origin_host  <code>instance-attribute</code>","text":"<pre><code>origin_host: bytes\n</code></pre>"},{"location":"api/commands/re_auth/#diameter.message.commands.re_auth.ReAuthRequest.origin_realm","title":"origin_realm  <code>instance-attribute</code>","text":"<pre><code>origin_realm: bytes\n</code></pre>"},{"location":"api/commands/re_auth/#diameter.message.commands.re_auth.ReAuthRequest.origin_state_id","title":"origin_state_id  <code>instance-attribute</code>","text":"<pre><code>origin_state_id: int\n</code></pre>"},{"location":"api/commands/re_auth/#diameter.message.commands.re_auth.ReAuthRequest.proxy_info","title":"proxy_info  <code>instance-attribute</code>","text":"<pre><code>proxy_info: list[ProxyInfo]\n</code></pre>"},{"location":"api/commands/re_auth/#diameter.message.commands.re_auth.ReAuthRequest.re_auth_request_type","title":"re_auth_request_type  <code>instance-attribute</code>","text":"<pre><code>re_auth_request_type: int\n</code></pre>"},{"location":"api/commands/re_auth/#diameter.message.commands.re_auth.ReAuthRequest.route_record","title":"route_record  <code>instance-attribute</code>","text":"<pre><code>route_record: list[bytes]\n</code></pre>"},{"location":"api/commands/re_auth/#diameter.message.commands.re_auth.ReAuthRequest.session_id","title":"session_id  <code>instance-attribute</code>","text":"<pre><code>session_id: str\n</code></pre>"},{"location":"api/commands/re_auth/#diameter.message.commands.re_auth.ReAuthRequest.user_name","title":"user_name  <code>instance-attribute</code>","text":"<pre><code>user_name: str\n</code></pre>"},{"location":"api/commands/re_auth/#diameter.message.commands.re_auth.FailedAvp","title":"FailedAvp  <code>dataclass</code>","text":"<p>A data container that represents the \"Failed-AVP\" grouped AVP.</p> <p><code>rfc6733</code>, defines this as just a list of arbitrary AVPs; the actual failed AVPs should be copied into the <code>additional_avps</code> attribute.</p>"},{"location":"api/commands/re_auth/#diameter.message.commands.re_auth.FailedAvp.additional_avps","title":"additional_avps  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>additional_avps: list[Avp] = dataclasses.field(default_factory=list)\n</code></pre>"},{"location":"api/commands/re_auth/#diameter.message.commands.re_auth.ProxyInfo","title":"ProxyInfo  <code>dataclass</code>","text":"<p>A data container that represents the \"Proxy-Info\" grouped AVP.</p>"},{"location":"api/commands/re_auth/#diameter.message.commands.re_auth.ProxyInfo.proxy_host","title":"proxy_host  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>proxy_host: bytes = None\n</code></pre>"},{"location":"api/commands/re_auth/#diameter.message.commands.re_auth.ProxyInfo.proxy_state","title":"proxy_state  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>proxy_state: bytes = None\n</code></pre>"},{"location":"api/commands/session_termination/","title":"Session Termination","text":"<p>API reference for <code>diameter.message.commands.session_termination</code>.</p> <p>This module contains Session-Termination Request and Answer messages, implementing AVPs documented in rfc6733.</p>"},{"location":"api/commands/session_termination/#diameter.message.commands.session_termination.SessionTermination","title":"SessionTermination","text":"<pre><code>SessionTermination(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>DefinedMessage</code></p> <p>A Session-Termination message.</p> <p>This message class lists message attributes based on the current RFC6733 as python properties, acessible as instance attributes. AVPs not listed in the base protocol can be retrieved using the SessionTermination.find_avps search method.</p> <p>Examples:</p> <p>AVPs accessible either as instance attributes or by searching:</p> <pre><code>&gt;&gt;&gt; msg = Message.from_bytes(b\"...\")\n&gt;&gt;&gt; msg.session_id\ndra1.mvno.net;2323;546\n&gt;&gt;&gt; msg.find_avps((AVP_SESSION_ID, 0))\n['dra1.mvno.net;2323;546']\n</code></pre> <p>When diameter message is decoded using Message.from_bytes, it returns either an instance of <code>SessionTerminationRequest</code> or <code>SessionTerminationAnswer</code> automatically:</p> <pre><code>&gt;&gt;&gt; msg = Message.from_bytes(b\"...\")\n&gt;&gt;&gt; assert msg.header.is_request is True\n&gt;&gt;&gt; assert isinstance(msg, SessionTerminationRequest)\n</code></pre> <p>When creating a new message, the <code>SessionTerminationRequest</code> or <code>SessionTerminationAnswer</code> class should be instantiated directly, and the values for AVPs set as class attributes:</p> <pre><code>&gt;&gt;&gt; msg = SessionTerminationRequest()\n&gt;&gt;&gt; msg.session_id = \"dra1.mvno.net;2323;546\"\n</code></pre> <p>Other, custom AVPs can be appended to the message using the SessionTermination.append_avp method, or by overwriting the <code>avp</code> attribute entirely. Regardless of the custom AVPs set, the mandatory values listed in RFC6733 must be set, however they can be set as <code>None</code>, if they are not to be used.</p> <p>Warning</p> <p>Every AVP documented for the subclasses of this command can be accessed as an instance attribute, even if the original network-received message did not contain that specific AVP. Such AVPs will be returned with the value <code>None</code> when accessed.</p> <p>Every other AVP not mentioned here, and not present in a network-received message will raise an <code>AttributeError</code> when being accessed; their presence should be validated with <code>hasattr</code> before accessing.</p>"},{"location":"api/commands/session_termination/#diameter.message.commands.session_termination.SessionTerminationAnswer","title":"SessionTerminationAnswer","text":"<pre><code>SessionTerminationAnswer(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>SessionTermination</code></p> <p>An Abort-Session-Answer message.</p> <p>Note</p> <p>The \"Class\" AVP can be accessed via <code>state_class</code> attribute, as \"class\" is a reserved keyword.</p>"},{"location":"api/commands/session_termination/#diameter.message.commands.session_termination.SessionTerminationAnswer.error_message","title":"error_message  <code>instance-attribute</code>","text":"<pre><code>error_message: str\n</code></pre>"},{"location":"api/commands/session_termination/#diameter.message.commands.session_termination.SessionTerminationAnswer.error_reporting_host","title":"error_reporting_host  <code>instance-attribute</code>","text":"<pre><code>error_reporting_host: bytes\n</code></pre>"},{"location":"api/commands/session_termination/#diameter.message.commands.session_termination.SessionTerminationAnswer.failed_avp","title":"failed_avp  <code>instance-attribute</code>","text":"<pre><code>failed_avp: int\n</code></pre>"},{"location":"api/commands/session_termination/#diameter.message.commands.session_termination.SessionTerminationAnswer.origin_host","title":"origin_host  <code>instance-attribute</code>","text":"<pre><code>origin_host: bytes\n</code></pre>"},{"location":"api/commands/session_termination/#diameter.message.commands.session_termination.SessionTerminationAnswer.origin_realm","title":"origin_realm  <code>instance-attribute</code>","text":"<pre><code>origin_realm: bytes\n</code></pre>"},{"location":"api/commands/session_termination/#diameter.message.commands.session_termination.SessionTerminationAnswer.origin_state_id","title":"origin_state_id  <code>instance-attribute</code>","text":"<pre><code>origin_state_id: int\n</code></pre>"},{"location":"api/commands/session_termination/#diameter.message.commands.session_termination.SessionTerminationAnswer.proxy_info","title":"proxy_info  <code>instance-attribute</code>","text":"<pre><code>proxy_info: list[ProxyInfo]\n</code></pre>"},{"location":"api/commands/session_termination/#diameter.message.commands.session_termination.SessionTerminationAnswer.redirect_host","title":"redirect_host  <code>instance-attribute</code>","text":"<pre><code>redirect_host: list[str]\n</code></pre>"},{"location":"api/commands/session_termination/#diameter.message.commands.session_termination.SessionTerminationAnswer.redirect_host_usage","title":"redirect_host_usage  <code>instance-attribute</code>","text":"<pre><code>redirect_host_usage: int\n</code></pre>"},{"location":"api/commands/session_termination/#diameter.message.commands.session_termination.SessionTerminationAnswer.redirect_max_cache_time","title":"redirect_max_cache_time  <code>instance-attribute</code>","text":"<pre><code>redirect_max_cache_time: int\n</code></pre>"},{"location":"api/commands/session_termination/#diameter.message.commands.session_termination.SessionTerminationAnswer.result_code","title":"result_code  <code>instance-attribute</code>","text":"<pre><code>result_code: int\n</code></pre>"},{"location":"api/commands/session_termination/#diameter.message.commands.session_termination.SessionTerminationAnswer.session_id","title":"session_id  <code>instance-attribute</code>","text":"<pre><code>session_id: str\n</code></pre>"},{"location":"api/commands/session_termination/#diameter.message.commands.session_termination.SessionTerminationAnswer.state_class","title":"state_class  <code>instance-attribute</code>","text":"<pre><code>state_class: list[bytes]\n</code></pre>"},{"location":"api/commands/session_termination/#diameter.message.commands.session_termination.SessionTerminationAnswer.user_name","title":"user_name  <code>instance-attribute</code>","text":"<pre><code>user_name: str\n</code></pre>"},{"location":"api/commands/session_termination/#diameter.message.commands.session_termination.SessionTerminationRequest","title":"SessionTerminationRequest","text":"<pre><code>SessionTerminationRequest(header: MessageHeader = None, avps: list[Avp] = None)\n</code></pre> <p>             Bases: <code>SessionTermination</code></p> <p>An Abort-Session-Request message.</p>"},{"location":"api/commands/session_termination/#diameter.message.commands.session_termination.SessionTerminationRequest.auth_application_id","title":"auth_application_id  <code>instance-attribute</code>","text":"<pre><code>auth_application_id: int\n</code></pre>"},{"location":"api/commands/session_termination/#diameter.message.commands.session_termination.SessionTerminationRequest.destination_host","title":"destination_host  <code>instance-attribute</code>","text":"<pre><code>destination_host: bytes\n</code></pre>"},{"location":"api/commands/session_termination/#diameter.message.commands.session_termination.SessionTerminationRequest.destination_realm","title":"destination_realm  <code>instance-attribute</code>","text":"<pre><code>destination_realm: bytes\n</code></pre>"},{"location":"api/commands/session_termination/#diameter.message.commands.session_termination.SessionTerminationRequest.origin_host","title":"origin_host  <code>instance-attribute</code>","text":"<pre><code>origin_host: bytes\n</code></pre>"},{"location":"api/commands/session_termination/#diameter.message.commands.session_termination.SessionTerminationRequest.origin_realm","title":"origin_realm  <code>instance-attribute</code>","text":"<pre><code>origin_realm: bytes\n</code></pre>"},{"location":"api/commands/session_termination/#diameter.message.commands.session_termination.SessionTerminationRequest.origin_state_id","title":"origin_state_id  <code>instance-attribute</code>","text":"<pre><code>origin_state_id: int\n</code></pre>"},{"location":"api/commands/session_termination/#diameter.message.commands.session_termination.SessionTerminationRequest.proxy_info","title":"proxy_info  <code>instance-attribute</code>","text":"<pre><code>proxy_info: list[ProxyInfo]\n</code></pre>"},{"location":"api/commands/session_termination/#diameter.message.commands.session_termination.SessionTerminationRequest.route_record","title":"route_record  <code>instance-attribute</code>","text":"<pre><code>route_record: list[bytes]\n</code></pre>"},{"location":"api/commands/session_termination/#diameter.message.commands.session_termination.SessionTerminationRequest.session_id","title":"session_id  <code>instance-attribute</code>","text":"<pre><code>session_id: str\n</code></pre>"},{"location":"api/commands/session_termination/#diameter.message.commands.session_termination.SessionTerminationRequest.state_class","title":"state_class  <code>instance-attribute</code>","text":"<pre><code>state_class: list[bytes]\n</code></pre>"},{"location":"api/commands/session_termination/#diameter.message.commands.session_termination.SessionTerminationRequest.termination_cause","title":"termination_cause  <code>instance-attribute</code>","text":"<pre><code>termination_cause: int\n</code></pre>"},{"location":"api/commands/session_termination/#diameter.message.commands.session_termination.SessionTerminationRequest.user_name","title":"user_name  <code>instance-attribute</code>","text":"<pre><code>user_name: str\n</code></pre>"},{"location":"api/commands/session_termination/#diameter.message.commands.session_termination.ProxyInfo","title":"ProxyInfo  <code>dataclass</code>","text":"<p>A data container that represents the \"Proxy-Info\" grouped AVP.</p>"},{"location":"api/commands/session_termination/#diameter.message.commands.session_termination.ProxyInfo.proxy_host","title":"proxy_host  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>proxy_host: bytes = None\n</code></pre>"},{"location":"api/commands/session_termination/#diameter.message.commands.session_termination.ProxyInfo.proxy_state","title":"proxy_state  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>proxy_state: bytes = None\n</code></pre>"},{"location":"guide/","title":"Using the diameter stack","text":"<p>The <code>diameter</code> package offers tools for parsing and creating AVPs, parsing and creating diameter messages, connecting to diameter peers and writing diameter applications.</p>"},{"location":"guide/#modules","title":"Modules","text":"<p>The entire package can be imported as <code>diameter</code>. It provides following  importable modules:</p> <ul> <li><code>diameter.message</code><ul> <li><code>diameter.message.avp</code></li> <li><code>diameter.message.commands</code></li> <li><code>diameter.message.constants</code></li> </ul> </li> <li><code>diameter.node</code><ul> <li><code>diameter.node.application</code></li> <li><code>diameter.node.peer</code></li> </ul> </li> </ul>"},{"location":"guide/#avp-and-message-modules","title":"AVP and message modules","text":"<p>The AVP and message handling modules are part of <code>diameter.message</code>.</p> <pre><code># base class for parsing and creating AVPs\nfrom diameter.message import Avp\n\n# subclasses of AVPs are in the `avp` module\nfrom diameter.message.avp import AvpTime, AvpOctetString\n\n# all package constants for AVPs, applications, vendors, enums etc\nfrom diameter.message.constants import *\n</code></pre> <p>See working with AVPs for a guide on AVPs.</p> <pre><code># base class for parsing and creating messages\nfrom diameter.message import Message\n\n# subclasses of messages ae in the `commands` module\nfrom diameter.message.commands import AbortSessionRequest, ReAuthRequest\n</code></pre> <p>See working with messages for a guide on diameter messages.</p>"},{"location":"guide/#node-application-and-peer-modules","title":"Node, application and peer modules","text":"<p>The diameter connectivity and application support are part of <code>diameter.node</code>.</p> <pre><code># Nodes and peers\nfrom diameter.node import Node\nfrom diameter.node.peer import Peer, PeerConnection\n</code></pre> <p>See connecting to peers for a guide on node and peer connectivity.</p> <pre><code># application base classes\nfrom diameter.node.application import Application, SimpleThreadingApplication\n</code></pre> <p>See application basics and sample application for guides on writing applications.</p>"},{"location":"guide/application/","title":"Working with diameter applications","text":"<p>A diameter application is the highest level of abstraction provided by the  <code>diameter</code> package. It automates tasks such as:</p> <ul> <li>Synchronous return of answers after sending messages</li> <li>Tracking requests that require answers</li> <li>Routing requests to any suitable peers, including load balancing</li> <li>Constructing answers from received request messages</li> </ul> <p>An \"application\" is any instance of a subclass of  <code>Application</code>. An application is  handed over to a configured node and the node will route every received request and answer message to the application, when necessary. Protocol-level message exchanges, i.e. CER (Capabilities-Exchange), DWR (Device-Watchdog) and DPR (Disconnect-Peer) never reach any application, but every other message is  expected to be handled by at least one application.</p> <p>If a node receives a message that no application has been configured to handle, it will reject the message with a <code>DIAMETER_APPLICATION_UNSUPPORTED</code> error.</p> <p>An example of the most basic client application:</p> <pre><code>from diameter.message import Message\nfrom diameter.message.constants import *\nfrom diameter.node import Node\nfrom diameter.node.application import SimpleThreadingApplication\n\nmy_app = SimpleThreadingApplication(APP_DIAMETER_BASE_ACCOUNTING, \n                                    is_acct_application=True)\n\nnode = Node(\"peername.gy\", \"realm.net\")\npeer = node.add_peer(\"aaa://ocs2.gy;transport=sctp\", \"realm.net\", \n                     ip_addresses=[\"10.16.0.8\", \"10.16.5.8\"], \n                     is_persistent=True)\nnode.add_application(my_app, [peer])\n\nmsg = Message()\n\nmy_app.wait_for_ready()\nanswer = my_app.send_request(msg, timeout=10)\n</code></pre> <p>The <code>add_application</code> call configures  also the peers that the application will use. More than one application of  same type can be added at the same time, as long as they use different peers.</p> <p>The application provides a  <code>wait_for_ready</code> method,  which will block until at least one of the configured peers becomes available  to receive requests.</p> <p>The <code>send_request</code>  application instance method will block until an answer message has been  received, and then returns the message, synchronously.</p> <p>The <code>diameter</code> package offers three different application implementations:</p> <code>Application</code> <p>The most basic form of an application. Must be subclassed and contains two  methods, <code>handle_request</code>, which must be overridden, and <code>handle_answer</code>, which may be overriden, but is usually not necessary. </p> <p>The <code>Application</code> class calls internally <code>handle_request</code> for each  received diameter request in the main thread. It calls <code>handle_answer</code> for each answer that comes unexpected, i.e. without a request waiting for it.</p> <pre><code>from diameter.message import Message\nfrom diameter.message.constants import *\nfrom diameter.node import Node\nfrom diameter.node.application import Application\n\nclass MyApplication(Application):\n    def handle_request(self, message: Message):\n        print(\"Got request\", message)\n\nmy_app = MyApplication(APP_DIAMETER_BASE_ACCOUNTING, \n                       is_acct_application=True)\n\nnode = Node(\"peername.gy\", \"realm.net\")\npeer = node.add_peer(\"aaa://ocs2.gy;transport=sctp\", \"realm.net\")\nnode.add_application(my_app, [peer])\n</code></pre> <p>Warning</p> <p>The request and answer are called in the main <code>Node</code> work thread and  they will block the node from processing any other messages. When this class is used, the implementing party is expected to build a queue and/or threading based solution on top, which would not block the main thread.</p> <code>ThreadingApplication</code> <p>A variation of application, which spawns a new thread for each incoming  request, up to an optional maximum amount of threads. Must be subclassed. Also contains two methods, <code>handle_request</code>, which must be overridden,  and <code>handle_answer</code>, which may be overriden, but is usually not necessary.</p> <p>Unlike in the base <code>Application</code> class, the threading application expects that the overridden <code>handle_request</code> returns a valid diameter message as an answer to the received request. Failing to do so results in an automatic  generation of a <code>DIAMETER_UNABLE_TO_COMPLY</code> error message.</p> <pre><code>from diameter.message import Message\nfrom diameter.message.constants import *\nfrom diameter.node import Node\nfrom diameter.node.application import ThreadingApplication\n\nclass MyApplication(ThreadingApplication):\n    def handle_request(self, message: Message) -&gt; Message:\n        print(\"Got request\", message)\n        answer = self.generate_answer(message)\n        return answer\n\nmy_app = MyApplication(APP_DIAMETER_BASE_ACCOUNTING, \n                       is_acct_application=True,\n                       max_threads=50)\n\nnode = Node(\"peername.gy\", \"realm.net\")\npeer = node.add_peer(\"aaa://ocs2.gy;transport=sctp\", \"realm.net\")\nnode.add_application(my_app, [peer])\n</code></pre> <code>SimpleThreadingApplication</code> <p>A variation of threading application, which does not need to be subclassed  and handles incoming requests only optionally. Also spawns a new thread for  each incoming request, up to an optional maximum amount of threads. </p> <p>In order to receive requests, the <code>SimpleThreadingApplication</code> accepts a  callback method in its constructor and calls it in a separate spawned  thread. Similar to the threading application, the callback function must return a valid answer, otherwise a <code>DIAMETER_UNABLE_TO_COMPLY</code> error is  sent back to the network.</p> <p>If no callback is provided, the <code>SimpleThreadingApplication</code> acts as a  client only and accepts no incoming requests.</p> <pre><code>from diameter.message import Message\nfrom diameter.message.constants import *\nfrom diameter.node import Node\nfrom diameter.node.application import SimpleThreadingApplication\n\ndef recv_request(app: SimpleThreadingApplication, message: Message) -&gt; Message:\n    print(\"Got request\", message, \"through application\", app)\n    answer = app.generate_answer(message)\n    answer.result_code = E_RESULT_CODE_DIAMETER_SUCCESS\n    return answer\n\nmy_app = SimpleThreadingApplication(APP_DIAMETER_BASE_ACCOUNTING, \n                                    is_acct_application=True,\n                                    max_threads=50,\n                                    request_handler=recv_request)\n\nnode = Node(\"peername.gy\", \"realm.net\")\npeer = node.add_peer(\"aaa://ocs2.gy;transport=sctp\", \"realm.net\")\nnode.add_application(my_app, [peer])\n</code></pre>"},{"location":"guide/avp/","title":"Parsing and writing AVPs","text":"<p>The <code>diameter</code> package contains an extensive dictionary, with ~2700 AVPs,  ~140 Applications, ~100 command codes, ~30 Vendors and ~2400 ENUM values  defined. These can be imported as:</p> <pre><code>from diameter.message.constants import *\n</code></pre> <p>This imports following constants:</p> <ul> <li><code>APP_</code>, application identifiers, e.g. <code>APP_3GPP_GX</code></li> <li><code>VENDOR_</code>, vendor codes, e.g. <code>VENDOR_NOKIA</code></li> <li><code>CMD_</code>, diameter command codes, e.g. <code>CMD_ACCOUNTING</code></li> <li><code>AVP_</code>, diameter AVPs. These are either labeled <code>AVP_&lt;name&gt;</code>, for the     diameter base protocol (e.g. <code>AVP_SERVICE_TYPE</code>), or <code>AVP_&lt;vendor&gt;_&lt;name&gt;</code>,     for the vendor-specific AVPs (e.g. <code>AVP_TGPP_GGSN_ADDRESS</code>)</li> <li><code>E_</code>, for all the enumerations, e.g. <code>E_DISCONNECT_CAUSE_BUSY</code></li> </ul> <p>The package does support also creating and parsing AVPs that are not included in the dictionary, as long as the AVP code and its type is known.</p>"},{"location":"guide/avp/#reading-an-avp","title":"Reading an AVP","text":"<p>Each AVP is an instance of <code>Avp</code> and consists of  attributes <code>code</code>, <code>is_mandatory</code>, <code>is_private</code>, <code>is_vendor</code>, <code>length</code>,  <code>vendor_id</code> and <code>value</code>. </p> <p>Most commonly, AVPs are received as bytes from the network and can be converted into their Python types by using  <code>Avp.from_bytes</code>.</p> <pre><code>from diameter.message import Avp\nfrom diameter.message.constants import *\n\navp_bytes = bytes.fromhex(\"000001cd40000016333232353140336770702e6f72670000\")\na = Avp.from_bytes(avp_bytes)\n\nassert a.code == 461\nassert a.code == AVP_SERVICE_CONTEXT_ID\nassert a.is_mandatory is True\nassert a.is_private is False\nassert a.is_vendor is False\nassert a.length == 22\nassert a.value == \"32251@3gpp.org\"\n</code></pre> <p>When parsing, as long as the AVP is of a known type, an instance of a subclass  of <code>Avp</code> is returned. Each subclass represents a specific AVP type; e.g. an \"Integer32\" AVP is represented by  <code>AvpInteger32</code>, a \"Grouped\" AVP is  <code>AvpGrouped</code>, etc.</p> <p>The AVPs hold two attributes, <code>payload</code> and <code>value</code>. The payload is the actual encoded byte string, while value is the Python value that can be set and read.</p> <pre><code>from diameter.message.avp import AvpInteger32\nfrom diameter.message.constants import *\n\na = AvpInteger32(AVP_ACCT_INPUT_PACKETS)\na.value = 294967\n\nassert a.value == 294967  # Python value\nassert a.payload == b\"\\x00\\x04\\x807\"  # Network bytes representation\n</code></pre> <p>Each individual AVP type has their specific python value, refer to  AVP API reference for details.</p>"},{"location":"guide/avp/#creating-an-avp","title":"Creating an AVP","text":"<p><code>Avp.new</code> class method is the expected way to  build new AVPs. It ensures that a correct type of AVP is returned,  i.e \"Float32\", \"OctetString\" etc. AVPs encode and decode their content automatically according to the RFC, when their <code>value</code> attribute is altered. The actual, byte-encoded payload is stored in the <code>payload</code> attribute.</p> <pre><code>from diameter.message import Avp\nfrom diameter.message.avp import AvpUtf8String\nfrom diameter.message.constants import *\n\na = Avp.new(AVP_USER_NAME)\n# Has returned an instance of AvpUtf8String\nassert isinstance(a, AvpUtf8String)\na.value = \"\u6c49\u8bed\"\n\n# `value` is human-readable, `payload` has the network bytes\nassert a.value == \"\u6c49\u8bed\"\nassert a.payload == b\"\\xe6\\xb1\\x89\\xe8\\xaf\\xad\"\n</code></pre> <p>When creating an AVP, its vendor must be specified, if the AVP does not belong to the Diameter Base RFCs:</p> <pre><code>from diameter.message import Avp\nfrom diameter.message.constants import *\n\nua = Avp.new(AVP_CISCO_USER_AGENT, VENDOR_CISCO)\n</code></pre> <p>When creating an AVP, its flags and value can also be set during creation,  which can be practical especially for nested \"Grouped\" type AVPs:</p> <pre><code>from diameter.message import Avp\nfrom diameter.message.constants import *\n\nps_information = Avp.new(AVP_TGPP_PS_INFORMATION, VENDOR_TGPP, value=[\n    Avp.new(AVP_TGPP_3GPP_PDP_TYPE, VENDOR_TGPP, value=0),\n    Avp.new(AVP_TGPP_PDP_ADDRESS, VENDOR_TGPP, value=\"10.40.93.32\")\n])\n</code></pre> <p>Each individual AVP type has their specific type of python value, and  attempting to set a value that has an invalid type will raise an exception.  Refer to AVP API reference for details for each AVP  type.</p>"},{"location":"guide/avp/#using-the-avp-dictionary","title":"Using the AVP dictionary","text":"<p>The package contains a large dictionary that holds a definition for each AVP,  with which AVPs can be constructed. This dictionary is automatically consulted when creating AVPs using <code>Avp.new</code> and <code>Avp.from_bytes</code>, however it permits  also direct access:</p> <pre><code>from diameter.message.avp import AvpEnumerated\nfrom diameter.message.avp.dictionary import AVP_DICTIONARY\nfrom diameter.message.constants import *\n\navp_def =  AVP_DICTIONARY[AVP_SERVICE_TYPE]\n\nassert avp_def[\"name\"] == \"Service-Type\"\nassert avp_def[\"type\"] == AvpEnumerated\nassert avp_def[\"mandatory\"] is True\n</code></pre> <p>Vendor-specific AVPs are stored in individual dictionaries, separate for each  vendor:</p> <pre><code>from diameter.message.avp import AvpUtf8String\nfrom diameter.message.avp.dictionary import AVP_VENDOR_DICTIONARY\nfrom diameter.message.constants import *\n\navp_def =  AVP_VENDOR_DICTIONARY[VENDOR_TGPP][AVP_TGPP_CONTENT_TYPE]\n\nassert avp_def[\"name\"] == \"Content-Type\"\nassert avp_def[\"type\"] == AvpUtf8String\nassert avp_def[\"mandatory\"] is True\nassert avp_def[\"vendor\"] == 10415\nassert avp_def[\"vendor\"] == VENDOR_TGPP\n</code></pre>"},{"location":"guide/message/","title":"Parsing and writing messages","text":"<p>The <code>diameter</code> package contains python implementations for the command messages described in the Diameter Base protocol, and for other, commonly used messages, such as credit control.</p>"},{"location":"guide/message/#reading-mesasges","title":"Reading mesasges","text":"<p>Messages received from the network can be converted directly to Python types  using <code>Message.from_bytes</code>.</p> <pre><code>from diameter.message import Message\nfrom diameter.message.commands import CreditControlRequest\n\nccr = Message.from_bytes(b\"\\x01\\x00\\x02\\x90\\xc0 ... \")\nassert isinstance(ccr, CreditControlRequest)\n</code></pre> <p>Messages that have a Python implementation (e.g. \"Accounting\", \"Credit-Control\") are further split into \"Request\" and \"Answer\" classes. Parsing an Accounting message that is also a request will return an instance of  <code>AccountingRequest</code>, while an answer would return an instance of  <code>AccountingRequest</code>.</p> <p>Python implementations with direct attribute access are currently provided for  the following Diameter Commands:</p> <ul> <li>Abort-Session</li> <li>Accounting</li> <li>Capabilities-Exchange</li> <li>Credit-Control</li> <li>Device-Watchdog</li> <li>Disconnect-PeerConnection</li> <li>Re-Auth</li> <li>Session-Termination</li> </ul> <p>For messages that do not have a Python implementation, an instance of  <code>Message</code>, or one of its subclasses is returned.  For these, refer to the full list.</p>"},{"location":"guide/message/#reading-avps","title":"Reading AVPs","text":"<p>For any command message that has a Python implementation, any AVP part of the  RFC can be accessed as an instance attribute:</p> <pre><code>from diameter.message import Message\n\n# Will generate a diameter.message.commands.CreditControlRequest instance\nccr = Message.from_bytes(b\"\\x01\\x00\\x02\\x90\\xc0 ... \")\n\n# AVPs are directly accessible as attributes:\nassert ccr.origin_host == b\"dra2.gy.mno.net\"\nassert ccr.destination_realm == b\"mvno.net\"\n# Works also for Grouped AVPs:\nassert ccr.multiple_services_credit_control[0].requested_service_unit.cc_total_octets == 0\n</code></pre> <p>For AVPs not part of the RFCs, a <code>find_avps</code>  instance method is provided, which can be used to find any AVP within a message:</p> <pre><code>from diameter.message import Message\nfrom diameter.message.constants import *\n\n# Will generate a diameter.message.commands.CreditControlRequest instance\nccr = Message.from_bytes(b\"\\x01\\x00\\x02\\x90\\xc0 ... \")\n\n# Find accepts tuples of AVP-vendor pairs to search. More than one pair is \n# interpreted as a nested chain, i.e. an AVP within a grouped AVP. This chain \n# searches for a \"3GPP-RAT-Type\" AVP within a \"PS-Information\" AVP within a \n# \"Service-Information\" AVP, all TGPP vendor AVPs. \navps = ccr.find_avps(\n    (AVP_TGPP_SERVICE_INFORMATION, VENDOR_TGPP), \n    (AVP_TGPP_PS_INFORMATION, VENDOR_TGPP),\n    (AVP_TGPP_3GPP_RAT_TYPE, VENDOR_TGPP))\nassert avps[0].value == b\"\\x06\"\n</code></pre> <p>This will also work for message types that have no Python implementation:</p> <pre><code>from diameter.message import Message\nfrom diameter.message.constants import *\n\n# Contains a 3GPP-Update-Location-Request\nulr = Message.from_bytes(b\"\\x01\\x00\\x02\\xc8\\xc0\\x00 ... \")\nassert ulr.session_id == \"\"  # Raises an AttributeError\n\n# Searching will work:\nsession_id = ulr.find_avps((AVP_SESSION_ID, 0))[0]\n</code></pre>"},{"location":"guide/message/#creating-messages","title":"Creating messages","text":"<p>Message types that have a Python implementation can be built by creating new  instances of the needed type, and AVPs can be set directly as instance  attributes.</p> <pre><code>from diameter.message.commands import CreditControlRequest\nfrom diameter.message.constants import *\n\nccr = CreditControlRequest()\n# AVPs included in the base RFCs can be set as instance attributes. AVPs that \n# are listed as mandatory in the spec are also mandatory here\nccr.session_id = \"dsrkat01.mnc003.mcc260.3gppnetwork.org;65574b0c-2d02\"\nccr.origin_host = b\"dra2.gy.mno.net\"\nccr.origin_realm = b\"mno.net\"\nccr.destination_realm = b\"mvno.net\"\nccr.service_context_id = \"32251@3gpp.org\"\nccr.cc_request_type = E_CC_REQUEST_TYPE_UPDATE_REQUEST\nccr.cc_request_number = 952\nccr.destination_host = b\"dra3.mvno.net\"\n\n# Message header can be manipulated as well:\nccr.header.hop_by_hop_identifier = 10001\nccr.header.end_to_end_identifier = 20001\nccr.header.is_proxyable = False\n\n# For AVPs that can appear multiple times, `add_` methods are provided:\nccr.add_subscription_id(E_SUBSCRIPTION_ID_TYPE_END_USER_E164, \"485089163847\")\nccr.add_subscription_id(E_SUBSCRIPTION_ID_TYPE_END_USER_IMSI, \"260036619905065\")\n\n# Message can be built by converting it into bytes, which returns the entire\n# message, including its header and auto-generates all AVPs\nccr_bytes = ccr.as_bytes()\n</code></pre> <p>Note</p> <p>There is no checking for mandatory AVPs being set; it is the responsibility of the implementing party to ensure that all AVPs required are included. Leaving out a required AVP will emit a debug log entry, but will produce no other visible warning.</p> <p>For commands that accept additional AVPs according to the RFCs, custom AVPs can be added:</p> <pre><code>from diameter.message import Avp\nfrom diameter.message.commands import AbortSessionRequest\nfrom diameter.message.constants import *\n\nasr = AbortSessionRequest()\nasr.append_avp(\n    Avp.new(AVP_TGPP_ABORT_CAUSE, VENDOR_TGPP, value=E_ABORT_CAUSE_BEARER_RELEASED)\n)\n</code></pre> <p>Commands can be constructed manually as well, in case a Python implementation is not ready yet, or if custom behaviour is required:</p> <pre><code>from diameter.message import Avp, Message\nfrom diameter.message.constants import *\n\nmsg = Message()\nmsg.header.command_code = 262\nmsg.header.is_request = True\nmsg.avps = [\n    Avp.new(AVP_SESSION_ID, value=\"mnc003.mcc228.3gppnetwork.org;02472683\")\n]\n# etc\nmsg.as_bytes()\n</code></pre>"},{"location":"guide/node/","title":"Connecting to Diameter Peers","text":"<p>The <code>diameter</code> package provides tools to connect to multiple diameter peers  within the same diameter realm, with automated CER/CEA, DWR/DWA and DPR/DPA  handling, as well as message routing to local applications.</p> <p>The diameter node implementation supports both TCP and SCTP transports. It does not support secure transports.</p>"},{"location":"guide/node/#diameter-node","title":"Diameter Node","text":"<p>A diameter node represents the local diameter peer. It can be either a server, or a client, with the only difference being in the applications that want to  receive requests (server) and applications that want to send requests (client) through the node.</p> <p>In both cases, the diameter node is the same, and it will handle messages  flowing in both directions.</p>"},{"location":"guide/node/#basic-client-usage","title":"Basic client usage","text":"<p>A basic node that acts as a client is constructed with <code>Node</code>.</p> <pre><code>from diameter.node import Node\n\nnode = Node(\"peername.gy\", \"realm.net\")\n</code></pre> <p>A client node with no other arguments than the origin host and the local realm name will connect to any other peer and will advertise support for every vendor known to the <code>diameter</code> package. If necessary, the list of advertised vendors can be limited with:</p> <pre><code>from diameter.message.constants import *\nfrom diameter.node import Node\n\nnode = Node(\"peername.gy\", \"realm.net\",\n            vendor_ids=[VENDOR_ETSI, VENDOR_TGPP, VENDOR_TGPP2])\n</code></pre> <p>A node will only establish outgoing connections to known peers. Each peer must be added individually:</p> <pre><code>from diameter.node import Node\n\nnode = Node(\"peername.gy\", \"realm.net\")\nnode.add_peer(\"aaa://ocs1.gy\", \"realm.net\", \n              ip_addresses=[\"10.16.0.7\"])\nnode.add_peer(\"aaa://ocs2.gy;transport=sctp\", \"realm.net\", \n              ip_addresses=[\"10.16.0.8\", \"10.16.5.8\"], is_persistent=True)\n</code></pre> <p>Adding a peer as <code>persistent</code> will result in the node establishing an outgoing  connection at startup and ensuring that the connection remains up, by means of reconnecting after connection loss, if necessary. A peer that is not set as  persistent will never be automatically connected to. </p> <p>Adding a peer without specifying its ip addresses will only make the peer  \"known\"; no outgoing connection is ever attempted and the initial connection  must be made by the peer themselves, towards our node (for this the node must  act as a server).</p> <p>Peers must be added using a \"DiameterURI\" syntax, consisting of a scheme, peer FQDN, a connection port and transport protocol. Valid URIs are for instance:</p> <ul> <li>aaa://node1.gy;3868;transport=tcp</li> <li>aaa://node1.gy.realm.net;9009;transport=sctp</li> </ul> <p>If not specified, a peer defaults <code>tcp</code> over  port <code>3868</code>. Whether the realm FQDN should contain also the realm name or not, depends on how the peer on the receiving side of the connection is configured.</p> <p>After one or more peers have been configured, it must be started with  <code>start</code> and stopped with  <code>stop</code>. When started, the node will establish an  outgoing connection with every connected peer and perform a CER/CEA message  exchange. When asked to stop, the node sends a DPR (Disconnect-Peer-Request)  towards every connected peer and ends its operations as soon as a  DPA (Disconnect-Peer-Answer) has been received from every peer.</p> <pre><code>from diameter.node import Node\n\nnode = Node(\"peername.gy\", \"realm.net\")\nnode.start()\n# wait\nnode.stop(wait_timeout=120, force=False)\n</code></pre> <p>The stop command has optional timeout and force arguments; the timeout argument controls how long the node should wait for DPAs to arrive and for the peer  connections to empty their outgoing message buffers before giving up and  exiting. The force argument will just close all connections without even  sending out DPRs first.</p> <p>For sending diameter messages through the node, see  writing diameter applications.</p>"},{"location":"guide/node/#starting-a-server","title":"Starting a server","text":"<p>Operating a node as a server is near-identical to starting a node as a client. The only difference is, that a server will be listening for incoming  connections on local socket(s):</p> <pre><code>from diameter.message.constants import *\nfrom diameter.node import Node\n\nnode = Node(\"peername.gy\", \"realm.net\",\n            ip_addresses=[\"10.17.20.9\", \"172.16.13.9\"],\n            tcp_port=3868,\n            sctp_port=3868,\n            vendor_ids=[VENDOR_ETSI, VENDOR_TGPP, VENDOR_TGPP2])\nnode.start()\n</code></pre> <p>The node can handle both TCP and SCTP transports simultaneously. More than one IP address can be provided for SCTP multi-homing. The same address list is  used for both TCP and SCTP. If more than one address is provided and only a  <code>tcp_port</code> is given, the node will only listen on the first address of the list.</p> <p>For sending and receiving diameter messages through the node, see  writing diameter applications.</p>"},{"location":"guide/node/#node-attributes","title":"Node attributes","text":"<p>A node has several attributes that can be used or altered after its creation:</p> <code>vendor_id</code> The vendor ID that node will advertise in every CER and CEA. Defaults to  99999, i.e. \"Unknown\". Can be changed at any time, though preferably before <code>Node.start()</code> is called. <code>product_name</code> The product name that the noed will advertise in CER and CEA. Defaults to  \"python-diameter\". Can be changed at any time, though preferably before <code>Node.start()</code> is called. <code>cea_timeout</code> Default time in seconds that the node will wait for a CEA to arrive after sending a CER. This can also be set individually for each peer. <code>cer_timeout</code> Default time in seconds that the node will wait for a CER to arrive after a connection attempt is received. This can also be set individually for  each peer. <code>dwa_timeout</code> Default time in seconds that the node will wait for a DWA to arrive after a DWR has been sent. This can also be set individually for each peer. <code>idle_timeout</code> Default time of peer inactivity, in seconds that the node will accept  before a DWR will be sent. This can also be set individually for each peer. <code>wakeup_interval</code> <p>Time in seconds between forced wakeups while waiting for connection sockets to become active. This timer value controls how often peer  timers are checked, how often reconnects are attempted and how often  statistics are dumped in the logfiles. </p> <p>As this also defines the interval at which peer timers are checked, it  is also the smallest possible value for a peer timer value. Setting  this value very low will consume more CPU, setting it too high will  make observing short timeouts impossible.</p> <p>This value also defines how long a node will continue to run, after  <code>stop</code> with <code>force</code> argument set to <code>True</code> is called.</p> <code>end_to_end_seq</code> <p>The end-to-end identifier generator. This must be used every time a new  request message is to be sent through the node:</p> <pre><code>n = Node()\nm = Message()\nm.header.end_to_end_identifier = n.end_to_end_seq.next_sequence()\n</code></pre> <p>Note that when working with applications, the end-to-end  identifier will be set automatically for every outgoing request.</p> <code>session_generator</code> <p>A generator that produces \"globally and eternally unique\" IDs, as required by rfc6733. The produced session IDs consist of the node's diameter  identity, a node startup timestamp and a 64-bit counter that is increased by one for each session ID and is initialised to a random integer at node  startup.</p> <pre><code>&gt;&gt;&gt; n = Node(\"test1.gy\")\n&gt;&gt;&gt; n.session_generator.next_id()\ntest1.gy;6571a525;5bd295f2;6c76d6b6\n&gt;&gt;&gt; n.session_generator.next_id()\ntest1.gy;6571a525;5bd295f2;6c76d6b7\n</code></pre> <code>peers</code> Contains a dictionary of all peers known to the node, both those that have  been configured manually using <code>add_peer</code> and those that have been  discovered. The dictionary holds host identities as strings as its keys and instances of <code>Peer</code> as its values."},{"location":"guide/node/#diameter-peer","title":"Diameter peer","text":"<p>An instance of <code>Peer</code> represents a single diameter peer in the realm, other than the local node. The local diameter node collects  one instance of <code>Peer</code> for each connection that it either makes, receives, will  connect to, or will accept a connection from.</p> <p>An instance of a peer is returned every time  <code>Node.add_peer</code> is called:</p> <pre><code>from diameter.node import Node\n\nnode = Node(\"peername.gy\", \"realm.net\")\npeer = node.add_peer(\"aaa://ocs2.gy;transport=sctp\", \"realm.net\", \n                     ip_addresses=[\"10.16.0.8\", \"10.16.5.8\"])\n</code></pre> <p>A configured peer can be passed on to a diameter application.</p> <p>An instance of a peer will exist always, whether the peer is connected or not. The connectivity of the peer is indicated by the  <code>Peer.connection</code> instance attribute,  which holds an instance of a <code>PeerConnection</code>  if the peer is currently connected, otherwise <code>None</code>.</p>"},{"location":"guide/node/#peer-attributes","title":"Peer attributes","text":"<p>Peers have several attributes that can be queried and/or altered after creation:</p> <code>cea_timeout</code> Time in seconds that the node will wait for a CEA to arrive for the peer  after sending a CER. Not set by default, uses the values configured for the node. <code>cer_timeout</code> Default time in seconds that the node will wait for a CER to arrive for the peer after a connection attempt is received.  Not set by default, uses  the values configured for the node. <code>dwa_timeout</code> Default time in seconds that the node will wait for a DWA to arrive for the peer after a DWR has been sent. Not set by default, uses the values  configured for the node. <code>idle_timeout</code> Time of peer inactivity, in seconds that the node will accept before a DWR  will be sent. Not set by default, uses the values configured for the node. <code>reconnect_wait</code> Time to wait before attempting a re-connect for a persistent peer. Must be set individually for each peer, there are no default values provided by the node. <code>connection</code> An instance of <code>PeerConnection</code>, if the peer is currently connected. <code>counters</code> An instance of <code>PeerCounters</code>, which counts each CER, CEA, DWR, DWA, DPR, DPA and other app-routed requests and answers individually. <p>For a full list of instance attributes, see <code>Peer API reference</code>.</p>"},{"location":"guide/node/#peer-connection-attributes","title":"Peer connection attributes","text":"<p>Peer connections have several attributes that can be queried and/or altered  after creation:</p> <code>auth_application_ids</code> and <code>acct_application_ids</code> List of authentication and accounting application IDs that have been  determined as the supported application IDs after a CER/CEA has taken place. <code>hop_by_hop_seq</code> <p>The hop-by-hop identifier generator. This must be used every time a new  request message is to be sent through the peer:</p> <pre><code>from diameter.node import Node\nfrom diameter.node.peer import PEER_READY_STATES\n\nn = Node()\n# just pick any ready peer\nusable_peers = [\n    peer for peer in node.peers.values()\n    if peer.conenction and peer.connection.state in PEER_READY_STATES]\npeer = usable_peers[0]\nm.header.hop_by_hop_identifier = peer.connection.hop_by_hop_seq.next_sequence()\n</code></pre> <p>Note that when working with applications, the end-to-end  identifier will be set automatically for every outgoing request, when  <code>Node.route_request</code> is used.</p> <code>state</code> <p>The current connection state. One of the <code>\"PEER_*\"</code> constants within  <code>diameter.node.peer</code>. A connection will go through state transition \"CONNECTING\" -&gt; \"CONNECTED\" -&gt; \"READY\" -&gt; \"DISCONNECTING\" -&gt; \"CLOSING\" -&gt; \"CLOSED\" and will accept requests and answers from other peers and own applications  when it is \"READY\". </p> <p>The \"ready\" state can have several sub-states. When checking readiness,  it should be checked that the <code>Peer.connection.state</code> is within  <code>diameter.peer.PEER_READY_STATES</code>.</p> <code>is_sender</code> and <code>is_receiver</code> These read-only attributes indicate the direction the original connection was established as. A \"receiver\" connection is one that was established by a remote peer towards us, a \"sender\" connection was established by us  towards a remote peer. <p>For a full list of connection instance attributes, see  <code>PeerConnection API reference</code>.</p>"},{"location":"guide/node/#sending-messages-through-a-peer","title":"Sending messages through a peer","text":"<p>Normally incoming and outgoing messages are expected to be handled and  generated by applications, however a message can also be manually pushed  through any connected peer:</p> <pre><code>from diameter.message.commands.re_auth import ReAuthRequest\nfrom diameter.node import Node\nfrom diameter.node.peer import PEER_READY_STATES\n\nnode = Node(\"peername.gy\", \"realm.net\")\npeer = node.add_peer(\"aaa://ocs2.gy;transport=sctp\", \"realm.net\", \n                     ip_addresses=[\"10.16.0.8\", \"10.16.5.8\"], \n                     is_persistent=True)\nnode.start()\n\n# ideally should wait until connection becomes available; the READY state is not \n# achieved until CER/CEA has completed, which is likely to take a few seconds\nif peer.connection and peer.connection.state in PEER_READY_STATES:\n    rar = ReAuthRequest()\n    rar.header.end_to_end_identifier = node.end_to_end_seq.next_sequence()\n    rar.header.hop_by_hop_identifier = peer.connection.hop_by_hop_seq.next_sequence()\n    rar.session_id = node.session_generator.next_id()\n    # set all other required attributes\n    peer.connection.add_out_msg(rar)\n</code></pre>"},{"location":"guide/sample_application/","title":"A sample application","text":"<p>This section goes through the <code>\"examples/credit_control_sms_client.py\"</code> file, which demonstrates how to build a diameter client that performs a single SMS charging request.</p>"},{"location":"guide/sample_application/#setting-up-logging","title":"Setting up logging","text":"<p>All parts of the diameter stack use logging extensively. For the purposes of this example, the logs will be dumped in the console.</p> <pre><code>import logging\n\nlogging.basicConfig(format=\"%(asctime)s %(name)s %(levelname)s %(message)s\")\n# this shows a human-readable message dump in the logs\nlogging.getLogger(\"diameter.peer.msg\").setLevel(logging.DEBUG)\n# this silences periodic dumping of peer statistics\nlogging.getLogger(\"diameter.stats\").setLevel(logging.INFO)\n</code></pre>"},{"location":"guide/sample_application/#creating-a-diameter-node","title":"Creating a diameter node","text":"<p>A node represents our own peer and is required for the connectivity to exist. The node will be configured with one remote peer, which is the destination of our charging request.</p> <pre><code>from diameter.message.constants import *\nfrom diameter.node import Node\n\n# Configure our client node\nnode = Node(\n    \"smsgw.gy\", \"testrealm.local\",\n    vendor_ids=[VENDOR_ETSI, VENDOR_TGPP, VENDOR_TGPP2])\n# Add the destination peer\nocs_cfg = node.add_peer(\n    \"aaa://ocs.gy\", \"testrealm.local\",\n    ip_addresses=[\"10.0.0.50\"], is_persistent=True)\nnode.start()\n</code></pre>"},{"location":"guide/sample_application/#creating-the-charging-application","title":"Creating the charging application","text":"<p>As we are going to act only as a client, our application can be as simple as  possible. An instance of <code>SimpleThreadingApplication</code> with no callback function to receive messages is sufficient.</p> <pre><code>from diameter.message.constants import *\nfrom diameter.node.application import SimpleThreadingApplication\n\n# Configure our client application. Credit Control Applications advertise their\n# application ID in auth-application-id.\nclient = SimpleThreadingApplication(\n    APP_DIAMETER_CREDIT_CONTROL_APPLICATION,\n    is_auth_application=True)\n# Add application for `ocs.gy` peer configured above\nnode.add_application(client, [ocs_cfg])\n</code></pre> <p>If we were to act as a server and also expect incoming requests, a callback  function should be passed for the <code>SimpleThreadingApplication</code> constructor.</p>"},{"location":"guide/sample_application/#constructing-a-charging-request","title":"Constructing a charging request","text":"<p>The charging request will be an instance of <code>CreditControlRequest</code>. The header values, e.g. the hop-by-hop identifier and the application ID will be set  automatically by the application as the message is submitted, but everything  else must be set manually.</p> <p>This example uses multiple services credit control to specify the requested units, which is a common approach. An alternative would be to provide the  requested units directly as a value for the <code>ccr.requested_service_unit</code>  attribute.</p> <p>The example also appends a custom AVP structure at the end, containing TGPP specified identifiers for an SMS submission, in our case the recipient address, the message data coding scheme and the type of the short message being sent.</p> <pre><code>import datetime\n\nfrom diameter.message import Avp\nfrom diameter.message.commands.credit_control import CreditControlRequest\nfrom diameter.message.commands.credit_control import RequestedServiceUnit\nfrom diameter.message.constants import *\n\n# Construct a credit control request\nccr = CreditControlRequest()\n\n# These are required:\nccr.session_id = client.node.session_generator.next_id()\nccr.origin_host = client.node.origin_host.encode()\nccr.origin_realm = client.node.realm_name.encode()\nccr.destination_realm = client.node.realm_name.encode()\nccr.auth_application_id = client.application_id\nccr.service_context_id = \"32274@3gpp.org\"  # SMS\nccr.cc_request_type = E_CC_REQUEST_TYPE_EVENT_REQUEST\nccr.cc_request_number = 1\n\n# These are usually wanted by charging servers:\nccr.user_name = \"diameter\"\nccr.event_timestamp = datetime.datetime.now()\nccr.requested_action = E_REQUESTED_ACTION_DIRECT_DEBITING\n\nccr.add_subscription_id(\n    subscription_id_type=E_SUBSCRIPTION_ID_TYPE_END_USER_E164,\n    subscription_id_data=\"41780000001\")\nccr.add_multiple_services_credit_control(\n    requested_service_unit=RequestedServiceUnit(cc_service_specific_units=1),\n    service_identifier=1)\n\n# Adds the following 3GPP vendor-specific AVP structure at the end, which\n# contains the SMS type and recipient. Looks like:\n#\n#   Service-Information &lt;Code: 0x369, Flags: 0xc0 (VM-), Length: 120, Vnd: TGPP&gt;\n#     SMS-Information &lt;Code: 0x7d0, Flags: 0x80 (V--), Length: 108, Vnd: TGPP&gt;\n#       Data-Coding-Scheme &lt;Code: 0x7d1, Flags: 0x80 (V--), Length: 16, Vnd: TGPP, Val: 8&gt;\n#       SM-Message-Type &lt;Code: 0x7d7, Flags: 0x80 (V--), Length: 16, Vnd: TGPP, Val: 0&gt;\n#       Recipient-Info &lt;Code: 0x7ea, Flags: 0x80 (V--), Length: 64, Vnd: TGPP&gt;\n#         Recipient-Address &lt;Code: 0x4b1, Flags: 0x80 (V--), Length: 52, Vnd: TGPP&gt;\n#           Address-Type &lt;Code: 0x383, Flags: 0xc0 (VM-), Length: 16, Vnd: TGPP, Val: 1&gt;\n#           Address-Data &lt;Code: 0x381, Flags: 0xc0 (VM-), Length: 23, Vnd: TGPP, Val: 41780000001&gt;\n#\n# Actual content wanted by the OCS on the receiving end may vary depending on\n# the vendor and their implementation.\nccr.append_avp(\n    Avp.new(AVP_TGPP_SERVICE_INFORMATION, VENDOR_TGPP, value=[\n        Avp.new(AVP_TGPP_SMS_INFORMATION, VENDOR_TGPP, value=[\n            Avp.new(AVP_TGPP_DATA_CODING_SCHEME, VENDOR_TGPP, value=8),\n            Avp.new(AVP_TGPP_SM_MESSAGE_TYPE, VENDOR_TGPP, value=E_SM_MESSAGE_TYPE_SUBMISSION),\n            Avp.new(AVP_TGPP_RECIPIENT_INFO, VENDOR_TGPP, value=[\n                Avp.new(AVP_TGPP_RECIPIENT_ADDRESS, VENDOR_TGPP, value=[\n                    Avp.new(AVP_TGPP_ADDRESS_TYPE, VENDOR_TGPP, value=E_ADDRESS_TYPE_MSISDN),\n                    Avp.new(AVP_TGPP_ADDRESS_DATA, VENDOR_TGPP, value=\"41780000001\")\n                ]),\n            ]),\n        ])\n    ])\n)\n</code></pre>"},{"location":"guide/sample_application/#sending-the-message","title":"Sending the message","text":"<p>The constructed message will be sent through the application. Calling  <code>wait_for_ready</code> before sending the first message is recommended, as our  destination peer will not accept any messages until the capabilities exchange procedure has been completed in the background. <code>wait_for_ready</code> will also  block if the remote peer has gone away.</p> <p>When sending a request through an application, the application will block  until a given timeout (default 30 seconds) has passed, waiting for an answer to arrive through the peer. If an answer is received, it is returned, otherwise an exception is raised.</p> <p>As we are only going to send one single message, the noed can be stopped  afterwards, which will cleanly disconnect from the remote peer.</p> <pre><code># Wait for CER/CEA to complete\nclient.wait_for_ready()\ncca = client.send_request(ccr, timeout=5)\n\n# Should print 2001, if all goes well\nprint(cca.result_code)\n\n# Disconnect from peer and exit\nnode.stop()\n</code></pre>"},{"location":"guide/sample_application/#the-complete-script","title":"The complete script","text":"<pre><code>import datetime\nimport logging\n\nfrom diameter.message import Avp\nfrom diameter.message.commands.credit_control import CreditControlRequest\nfrom diameter.message.commands.credit_control import RequestedServiceUnit\nfrom diameter.message.constants import *\nfrom diameter.node import Node\nfrom diameter.node.application import SimpleThreadingApplication\n\nlogging.basicConfig(format=\"%(asctime)s %(name)s %(levelname)s %(message)s\")\n# this shows a human-readable message dump in the logs\nlogging.getLogger(\"diameter.peer.msg\").setLevel(logging.DEBUG)\n# this silences periodic dumping of peer statistics\nlogging.getLogger(\"diameter.stats\").setLevel(logging.INFO)\n\n\n# Configure our client node\nnode = Node(\n    \"smsgw.gy\", \"testrealm.local\",\n    vendor_ids=[VENDOR_ETSI, VENDOR_TGPP, VENDOR_TGPP2])\n# Add the destination peer\nocs_cfg = node.add_peer(\n    \"aaa://ocs.gy\", \"testrealm.local\",\n    ip_addresses=[\"10.0.0.50\"], is_persistent=True)\nnode.start()\n\n\n# Configure our client application\nclient = SimpleThreadingApplication(\n    APP_DIAMETER_CREDIT_CONTROL_APPLICATION,\n    is_auth_application=True)\n# Add application for `ocs.gy` peer\nnode.add_application(client, [ocs_cfg])\n\n\n# Construct a credit control request\nccr = CreditControlRequest()\n\n# These are required:\nccr.session_id = client.node.session_generator.next_id()\nccr.origin_host = client.node.origin_host.encode()\nccr.origin_realm = client.node.realm_name.encode()\nccr.destination_realm = client.node.realm_name.encode()\nccr.auth_application_id = client.application_id\nccr.service_context_id = \"32274@3gpp.org\"\nccr.cc_request_type = E_CC_REQUEST_TYPE_EVENT_REQUEST\nccr.cc_request_number = 1\n\n# These are usually wanted by charging servers:\nccr.user_name = \"diameter\"\nccr.event_timestamp = datetime.datetime.now()\nccr.requested_action = E_REQUESTED_ACTION_DIRECT_DEBITING\n\nccr.add_subscription_id(\n    subscription_id_type=E_SUBSCRIPTION_ID_TYPE_END_USER_E164,\n    subscription_id_data=\"41780000001\")\nccr.add_multiple_services_credit_control(\n    requested_service_unit=RequestedServiceUnit(cc_service_specific_units=1),\n    service_identifier=1)\n\n# Adds the following 3GPP vendor-specific AVP structure at the end, which\n# contains the SMS type and recipient. Looks like:\n#\n#   Service-Information &lt;Code: 0x369, Flags: 0xc0 (VM-), Length: 120, Vnd: TGPP&gt;\n#     SMS-Information &lt;Code: 0x7d0, Flags: 0x80 (V--), Length: 108, Vnd: TGPP&gt;\n#       Data-Coding-Scheme &lt;Code: 0x7d1, Flags: 0x80 (V--), Length: 16, Vnd: TGPP, Val: 8&gt;\n#       SM-Message-Type &lt;Code: 0x7d7, Flags: 0x80 (V--), Length: 16, Vnd: TGPP, Val: 0&gt;\n#       Recipient-Info &lt;Code: 0x7ea, Flags: 0x80 (V--), Length: 64, Vnd: TGPP&gt;\n#         Recipient-Address &lt;Code: 0x4b1, Flags: 0x80 (V--), Length: 52, Vnd: TGPP&gt;\n#           Address-Type &lt;Code: 0x383, Flags: 0xc0 (VM-), Length: 16, Vnd: TGPP, Val: 1&gt;\n#           Address-Data &lt;Code: 0x381, Flags: 0xc0 (VM-), Length: 23, Vnd: TGPP, Val: 41780000001&gt;\n#\n# Actual content wanted by the OCS on the receiving end may vary depending on\n# the vendor and their implementation.\nccr.append_avp(\n    Avp.new(AVP_TGPP_SERVICE_INFORMATION, VENDOR_TGPP, value=[\n        Avp.new(AVP_TGPP_SMS_INFORMATION, VENDOR_TGPP, value=[\n            Avp.new(AVP_TGPP_DATA_CODING_SCHEME, VENDOR_TGPP, value=8),\n            Avp.new(AVP_TGPP_SM_MESSAGE_TYPE, VENDOR_TGPP, value=E_SM_MESSAGE_TYPE_SUBMISSION),\n            Avp.new(AVP_TGPP_RECIPIENT_INFO, VENDOR_TGPP, value=[\n                Avp.new(AVP_TGPP_RECIPIENT_ADDRESS, VENDOR_TGPP, value=[\n                    Avp.new(AVP_TGPP_ADDRESS_TYPE, VENDOR_TGPP, value=E_ADDRESS_TYPE_MSISDN),\n                    Avp.new(AVP_TGPP_ADDRESS_DATA, VENDOR_TGPP, value=\"41780000002\")\n                ]),\n            ]),\n        ])\n    ])\n)\n\n# Wait for CER/CEA to complete\nclient.wait_for_ready()\ncca = client.send_request(ccr, timeout=5)\n\n# Should print 2001, if all goes well\nprint(cca.result_code)\n\n# Disconnect from peer and exit\nnode.stop()\n</code></pre>"}]}